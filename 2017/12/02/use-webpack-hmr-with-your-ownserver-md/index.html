<!DOCTYPE html><html class="no-js"><head><meta charset="utf-8"><title>司马-Simmer-将webpack的热替换(HMR)整合到既有server（Express）</title><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.icon"><link rel="stylesheet" href="/css/style.css"><!-- detech broser's env --><script src="/js/modernizr.js" type="text/javascript"></script><meta name="description" content="A Blog Powered By Hexo"></head><body><div class="nav clearfix"><div title="隐藏导航" id="nav-btn" class="nav-guide"><i class="icon nav-icon">&#xe603;</i></div><div class="nav-inner  clearfix "><a href="/" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe606;</div><span>Home</span></div></a><a href="/archives" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe602;</div><span>Archives</span></div></a><a href="/photography" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe604;</div><span>摄影</span></div></a><a href="/tags" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe601;</div><span>Tags</span></div></a><a href="/about" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe605;</div><span>About</span></div></a></div></div><div class="wraper"><div class="main"><section class="content"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2017/12/02/use-webpack-hmr-with-your-ownserver-md/" class="post-title-link">将webpack的热替换(HMR)整合到既有server（Express）</a></h2><div class="post-subtitle clearfix"><span class="post-date">2017年12月2日</span><div class="post-tag"><a href="/2017/12/02/use-webpack-hmr-with-your-ownserver-md/"><sapn>webpack</sapn><i class="icon">&#xe600;</i></a><a href="/2017/12/02/use-webpack-hmr-with-your-ownserver-md/"><sapn>development</sapn><i class="icon">&#xe600;</i></a></div></div><div class="post-content"><img src="title:webpack-hmr-overview" class="webpack-hmr/webpack-hmr-overview.png" title="cover">
<p>注意：本篇不是一个讲解HMR原理的文章，仅仅阐述如何实现接入HMR。</p>
<h2><span id="背景">背景</span></h2><p>随着部门业务的发展，业务逻辑的不断发展，为了更好的应对业务的多变性，提高项目可维护性，我们提出了基于React的组件化工作流。<br><a id="more"></a><br>在项目的前期，我们将原先的jquery组件逐步的迁移至React组件，一个个的业务模块被拆分为可维护的组件及可复用组件，对于React，由于独有的<code>JSX</code>语法，页面的<code>html</code>结构和<code>js逻辑</code>混搭在一起，通常是下面这样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Avatar = <span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = somehandle(props.url); <span class="comment">// your js code ...</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"m-avatar"</span>&gt;</span><br><span class="line">      &lt;img src=&#123;url&#125; alt=&#123;props.alt || <span class="string">"用户头像"</span>&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>但是为了组件的统一维护性，需要将组件的样式也单独拆分到组件粒度并将组件的<code>.jsx</code>和<code>.scss</code>文件放在一个目录里面，以上面讲到的<code>Avatar</code>组件为例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...avatar/index.jsx</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./index.scss'</span>); <span class="comment">// 引入scss样式文件</span></span><br><span class="line"><span class="comment">//go you code...</span></span><br></pre></td></tr></table></figure>
<p>组件的目录结构为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--component</span><br><span class="line">----avatar</span><br><span class="line">------index.jsx (组件入口文件)</span><br><span class="line">------index.scss(组件级样式文件)</span><br><span class="line">------tool.js(组件使用的工具类)</span><br><span class="line">------etc...</span><br></pre></td></tr></table></figure>
<p>这个概念其实很早就有大神提出来了==&gt;<a href="https://github.com/fouber/blog/issues/10" target="_blank" rel="noopener">张云龙-前端工程-基础篇</a><br>当然，使用几乎无所不能的webpack可以达到我们的诉求。</p>
<h2><span id="痛处">痛处</span></h2><p>在迁移中我发现，由于前端开发中通过webpack来加载<code>.scss</code>文件资源，每次修改组件样式文件时，webpack的<code>watch</code>机制就会触发资源的重新打包，进而将整个page页面刷新（通过使用livereload来监听js文件改动）。而在这之前，也就是样式没有拆分到组件粒度之前，样式文件按照page为单位维护，通过<code>compass</code>+<code>livereload.js</code>来完成实时编译<code>.scss</code>文件并热替换样式文件的“一条龙”服务。</p>
<p>现在写组件样式就很不爽了，就改了一个背景色，整个页面需要重新reload。所以有没有解决方案，让样式文件能够在不刷新浏览器的情况下被应用？</p>
<p>答案是有的，可以通过webpack的HMR(Hot-Module-Replacement)可以实现模块的热替换，这其中就包含css模块。</p>
<h2><span id="了解hmr">了解HMR</span></h2><p>首先什么是HMR？原引<a href="https://webpack.js.org/concepts/hot-module-replacement/" target="_blank" rel="noopener">官方文档</a>的解释：</p>
<blockquote>
<p>Hot Module Replacement (HMR) exchanges, adds, or removes modules while an application is running, without a full reload. This can significantly speed up development in a few ways:</p>
<ul>
<li>Retain application state which is lost during a full reload.</li>
<li>Save valuable development time by only updating what’s changed.</li>
<li>Tweak styling faster – almost comparable to changing styles in the browser’s debugger.</li>
</ul>
</blockquote>
<p> 原引<a href="https://doc.webpack-china.org/concepts/hot-module-replacement" target="_blank" rel="noopener">中文文档</a>翻译：</p>
<blockquote>
<p>模块热替换(HMR - Hot Module Replacement)功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度：</p>
<ul>
<li>保留在完全重新加载页面时丢失的应用程序状态。</li>
<li>只更新变更内容，以节省宝贵的开发时间。</li>
<li>调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。</li>
</ul>
</blockquote>
<p>在前端开发过程中，我们需要不断的调整样式，通过webpack的HMR我们可以很方便的在保存应用状态前提下快速修改代码，极大的节省了开发时间和提升开发效率。</p>
<h2><span id="面临的选择">面临的选择</span></h2><p>通过查阅官方文档和相关资料，使用webpack的hmr有以下3种方式，可以根据情况作出选择：</p>
<ul>
<li>webpack-dev-server CLI</li>
<li>webpack-dev-server API</li>
<li><a href="https://github.com/glenjamin/webpack-hot-middleware" target="_blank" rel="noopener">webpack-hot-middleware</a></li>
</ul>
<p>下面简要概述这3种方式：</p>
<h3><span id="method-1-webpack-dev-server-cli">method-1 :webpack-dev-server CLI</span></h3><p>第一种方法是通过命令行的方式来启用webpack的HMR，移动到相关project目录下，配置相关webpack明令，对于<code>webpack-dev-server</code>CLI来说，可以接受通过<code>--config</code>配置传入的<code>webpack.config.js</code>配置文件。仅仅需要做以下事情即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> your-project-path</span><br><span class="line">npm install webpack webpack-dev-server --save-dev</span><br><span class="line">webpack-dev-server   --watch --hot -- other-options...</span><br></pre></td></tr></table></figure>
<p>这种方式可以方便的用来快速开始一个webpack项目，在真实的开发项目中，建议不要试用这种方式。</p>
<p>更多的webpack CLI配置命令<a href="https://webpack.github.io/docs/webpack-dev-server.html#webpack-dev-server-cli" target="_blank" rel="noopener">点击这里</a></p>
<h3><span id="method-2webpack-dev-server-api">method-2:webpack-dev-server API</span></h3><p>第二种方法是通过webpack-dev-server来启用HMR，这种方式需要修改webpack配置项，简单来说就是webpack本地开启一个server，浏览器加载的<code>boundle</code>中包含一个<code>javaScript runtime</code>可以通过socket和webpack-dev-server通信，具体查看<a href="https://www.andrewhfarmer.com/webpack-hmr-tutorial/" target="_blank" rel="noopener">这篇文章</a>来了解具体步骤。</p>
<h3><span id="method-3webpack-hot-middleware">method-3:webpack-hot-middleware</span></h3><p>第三种方法是通过设置<code>webpack-dev-middleware</code>+<code>webpack-hot-middleware</code>来完成代码热替换的，与其他2种方法都必须要使用<code>webpack-dev-server</code>不同的地方在于，方法三适合哪些即有项目。对即有的项目来说，有自己的一套本地server(通常是Express)，包含了其他一些针对本地server的处理，这个时候在强行再次起一个服务（<code>webpack-dev-server</code>）无疑是得不偿失的。通过<code>webpack-dev-middleware</code>和<code>webpack-hot-middleware</code>中间件来整合webpack热替换到即有本地服务中，从而享受webpack HMR带来的各种开发优势。</p>
<h2><span id="将webpack-hmr整合到express">将webpack HMR整合到Express</span></h2><p>在选择实现方案的时候，考虑到由于已经存在前端本地服务（Express），所以选择通过webpack-hot-middleware的方式来接入webpack的HMR。<br>需要执行以下几个步骤：</p>
<h3><span id="步骤1express接入webpack-dev-middleware">步骤1：Express接入webpack-dev-middleware</span></h3><p>首先，webpack-dev-mddleware是什么？</p>
<p>它是一个简单的webpack包装中间件，通过连接服务来提供从webpack打包好的文件。注意到它相比于将boundle打包成文件有以下优势：</p>
<ul>
<li>不会有硬盘文件的写入，它将打包好的文件存放在内存中。</li>
<li>当在watch模式下有文件改动，webpack-dev-middle将会延迟<code>boundle</code>的响应直到新的<code>boundle</code>打包完成（也就是说，你不需要在刷新页面前等待文件的重新打包）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> compiler = webpack(your_webpackConfig);</span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>)(compile, &#123;</span><br><span class="line">  <span class="comment">// required  打包好的boundle相对公共路径，此次设置为'/'</span></span><br><span class="line">  publicPath: your_webpackConfig.output.publicPath </span><br><span class="line">  <span class="comment">// other options see ==&gt; https://github.com/webpack/webpack-dev-middleware#usage</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<h2><span id="步骤2express接入webpack-hot-middleware">步骤2：Express接入webpack-hot-middleware</span></h2><p>什么是webpack-hot-middleware中间件？<br>通过webpack-hot-middleware中间件让你在既有server上添加热替换功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> compiler = webpack(your_webpackConfig);</span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">'webpack-hot-middleware'</span>(compiler, &#123;</span><br><span class="line">    log: <span class="built_in">console</span>.log, <span class="comment">// 控制台输出方法</span></span><br><span class="line">    path: <span class="string">'/__webpack_hmr'</span>, <span class="comment">// webpack hmr server 路径</span></span><br><span class="line">    heartbeat: <span class="number">10</span> * <span class="number">1000</span>,<span class="comment">// 轮询通信间隔</span></span><br><span class="line">    <span class="comment">// other options see ==&gt; </span></span><br><span class="line">    <span class="comment">// https://github.com/glenjamin/webpack-hot-middleware#documentation</span></span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure>
<h2><span id="步骤3修改webpack配置文件">步骤3：修改webpack配置文件</span></h2><p>首先，需要启用webpack的热加载功能，通过webpack自带的插件即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(key == <span class="string">'serve'</span>)&#123;<span class="comment">// 保证只在开发阶段试用webpack热替换</span></span><br><span class="line">    plugins = plugins.concat([</span><br><span class="line">      <span class="keyword">new</span> webpack.optimize.OccurrenceOrderPlugin(),</span><br><span class="line">      <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">      <span class="comment">// 启用热替换插件</span></span><br><span class="line">      <span class="keyword">new</span> webpack.NoErrorsPlugin()</span><br><span class="line">    ]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其次，修改每个入口文件配置，链接到webpack热加载服务器。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hotMiddlewareScript = <span class="string">'webpack-hot-middleware/client?path=/__webpack_hmr&amp;timeout=20000&amp;reload=true'</span>;</span><br><span class="line"><span class="comment">// 详细的配置访问==&gt; </span></span><br><span class="line"><span class="comment">//https://github.com/glenjamin/webpack-hot-middleware#config</span></span><br><span class="line"><span class="comment">//... 省略</span></span><br><span class="line"><span class="keyword">if</span>(key ==<span class="string">'serve'</span>)&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> entry <span class="keyword">in</span> entrys)&#123;</span><br><span class="line">   <span class="keyword">if</span>(entrys.hasOwnProperty(entry))&#123;</span><br><span class="line">     entrys[entry] = [entrys[entry], hotMiddlewareScript];</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3><span id="步骤4修改js代码">步骤4：修改js代码</span></h3><p>为了完成webpack的热替换，还需要在你的应用代码中添加一些额外的<code>代码</code>，这些额外的代码做的事情是移除一些可能对应用产生副作用的影响。</p>
<p>由于通过<a href="https://github.com/webpack-contrib/style-loader" target="_blank" rel="noopener">stlye-loader</a>来处理.css文件，而该loader自带模块热替换的功能，无需在应用代码中额外处理。</p>
<p>可以通过使用webpack提供的相关API来显示的处理，具体可以查看<a href="https://doc.webpack-china.org/api/hot-module-replacement" target="_blank" rel="noopener">webpack官网</a></p>
<p>至此，已经完成了所有的配置修改工作，现在启动express服务器，修改某一个引入的<code>.scss</code>文件，你会发现页面在不刷新的情况下重新应用了相关的样式文件。</p>
<h2><span id="遇到的问题">遇到的问题</span></h2><p>在将webpack热替换接入到项目中时，还遇到了其他的一些问题：</p>
<ul>
<li>路径匹配问题（由于window和linux系统分盘符导致的打包文件路径问题）</li>
<li>如何在不影响线上打包的情况下在开发环境下接入HMR</li>
<li>如何模版文件中的js文件路径和webpack打包到内存中的路径保持一致</li>
</ul>
<h2><span id="小结及反思">小结及反思</span></h2><p>通过此次在项目中成功接入webpack HMR，更加明确及熟悉了前端架构优化的流程。总结了以下几点：</p>
<ul>
<li>首先提出诉求，我们想要达成的目标是什么？==&gt; 热替换样式，不刷新页面</li>
<li>调研实现方法有哪几种？ ==&gt; 3种，webpack-dev-server CLI / webpack-dev-server API / webpack-hot-middleware</li>
<li>是否有合适方案／根据项目现有状况挑选一种最合适的实现方案==&gt; webpack-dev-middle+webpack-hot-middleware</li>
<li>实现注意事项有哪些？==&gt;路径匹配/环境区分/etc</li>
</ul>
<p>碍于篇幅，本篇仅仅解释了基于webpack的样式热替换，当然还可以实现让js文件热替换，可以查看<a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack官网</a>了解更多的loader和[HMR的API]（<a href="https://doc.webpack-china.org/api/hot-module-replacement）。" target="_blank" rel="noopener">https://doc.webpack-china.org/api/hot-module-replacement）。</a></p>
<h2><span id="参考文章">参考文章</span></h2><ul>
<li><a href="https://webpack.js.org/concepts/hot-module-replacement/" target="_blank" rel="noopener">webpack-doc</a></li>
<li><a href="https://www.andrewhfarmer.com/webpack-hmr-tutorial/" target="_blank" rel="noopener">webpack-hmr-tutorial</a></li>
<li><a href="https://github.com/glenjamin/webpack-hot-middleware/tree/master/example" target="_blank" rel="noopener">webpack-hot-middleware-example</a></li>
</ul>
<p>后续将会有另外的文章来讲解webpack热替换的原理，敬请期待：)</p>
</div></article></div><div class="paginator clearfix"><a href="/2017/12/17/summary-about-2017/" class="prev">上一篇</a><a href="/2017/05/11/javascript/what-i'm-thinking-when-writing-newpage-using-React/" class="next">下一篇</a></div></section><section class="footer"><div class="copyright">©2015-2019 <a href="/about/index.html">Simmer</a> | Front-ender | Amateur photographer. </div><div id="go-pg-top" style="display: none; opacity: 0.6;" title="返回顶部">TOP</div></section></div></div><script src="/js/jquery-1.11.1.js"></script><script src="/js/common.js"></script></script></body></html>