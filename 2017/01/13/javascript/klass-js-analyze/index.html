<!DOCTYPE html><html class="no-js"><head><meta charset="utf-8"><title>司马-Simmer-klass.js 源码分析</title><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.icon"><link rel="stylesheet" href="/css/style.css"><!-- detech broser's env --><script src="/js/modernizr.js" type="text/javascript"></script><meta name="description" content="A Blog Powered By Hexo"></head><body><div class="nav clearfix"><div title="隐藏导航" id="nav-btn" class="nav-guide"><i class="icon nav-icon">&#xe603;</i></div><div class="nav-inner  clearfix "><a href="/" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe606;</div><span>Home</span></div></a><a href="/archives" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe602;</div><span>Archives</span></div></a><a href="/photography" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe604;</div><span>摄影</span></div></a><a href="/tags" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe601;</div><span>Tags</span></div></a><a href="/about" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe605;</div><span>About</span></div></a></div></div><div class="wraper"><div class="main"><section class="content"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2017/01/13/javascript/klass-js-analyze/" class="post-title-link">klass.js 源码分析</a></h2><div class="post-subtitle clearfix"><span class="post-date">2017年1月13日</span><div class="post-tag"><a href="/2017/01/13/javascript/klass-js-analyze/"><sapn>source code analyze</sapn><i class="icon">&#xe600;</i></a></div></div><div class="post-content"><p><a href="https://github.com/ded/klass" target="_blank" rel="noopener">klass.js</a>是一个oop风格的javascript库，提供Javascript传统面对对象的编程风格。</p>
<h2><span id="起因">起因</span></h2><p>由于部门是从事电商领域，需要全面兼容不同的客户端，这就造成了我们前架构的“繁杂”，以PC端为例：jQuery + jqoteplus + freemarker-Template + React + klass + sass的混搭风你可能真的很少见过（微笑脸）。为了SEO友好，PC端大部分的页面都是使用传统的模版语言来进行后端渲染，前端复用效率比较低，这也就造成了可能只是一个小的需求修改，我们不得不深入到每一个具体的模版页面去修改，降低了工作效率不说，也很繁琐。好像有点跑题了，关于团队的项目后期有机会再聊～<br><a id="more"></a><br>作为一个电商部门，web页面中有许多公共的部分，例如页面头部的类目列表，顶部的用户信息栏、mini购物车等，这些公共的部分其实我们可以统一抽出来作为公共的业务逻辑进行打包处理。前面可能说了，作为电商网站，可能没法使用当前最新的前端技术栈，我们需要良好的SEO，需要兼容IE8（是的，不要惊讶我们还在兼容IE8），ES6甜甜的语法糖也因为项目在构建中的问题暂时没法使用，回归到ES5中，如何实现公共页面的逻辑统一封装？终于到了本文的正题了－使用<a href="https://github.com/ded/klass" target="_blank" rel="noopener">klass.js</a> a utility for creating expressive classes in JavaScript 一段在javascript中创建动态类的实用程序。</p>
<h2><span id="使用klass">使用klass</span></h2><p>使用klass创建一个类十分简单。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = klass(&#123;</span><br><span class="line">  initial: <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello "</span> + <span class="keyword">this</span>.name); <span class="comment">// Hello simmer</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> simmer = <span class="keyword">new</span> Person(<span class="string">"simmer"</span>, <span class="number">23</span>);</span><br><span class="line">simmer.sayHello();</span><br></pre></td></tr></table></figure></p>
<p>通过调用klass显式的传入一个包含键值对的对象进行，klass默认会寻找其中key为<code>initial</code>的属性作为构造函数借用的方法，这里可以设置实例对象的私有属性(包括静态属性和方法)。为什么说借用构造函数呢？因为真实的构造函数并不是<code>initial</code>，只是在真实的构造函数中通过<code>this.initial.apply(this, arguments)</code>来实现借用构造函数，这点后面会进行说明。除了<code>initial</code>方法之外，其他的属性都将会被添加到构造函数的原型对象中，作为原型的方法被所有的实例所共享。<br>当然，还有另外定义类的方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = klass(<span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;)</span><br><span class="line">  .method(&#123;</span><br><span class="line">    sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Hello"</span> + <span class="keyword">this</span>.name + <span class="string">"who is "</span> + <span class="keyword">this</span>.age + <span class="string">" years old"</span>); <span class="comment">//Hello sunny who is 23 years old</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="keyword">var</span> sunny = <span class="keyword">new</span> Person(<span class="string">"sunny"</span>, <span class="number">23</span>);</span><br><span class="line">sunny.sayHello();</span><br></pre></td></tr></table></figure></p>
<p>像上面这种定义类的方法可能更加接近原生的javascript中的构造函数定义类的方法， 构造函数中设置实例对象特有的属性/方法，在<code>Constructor.prototype</code>上添加实例共享方法/属性。<br>为了使得代码更加靠近传统的oop，组内现有的使用方式是第一种，这种写法也基本与ES6的class保持一致。抛开业务逻辑谈论是没有多少意义的，这里以一个简单的3个类为例子，<code>BaseComponent</code>、<code>BaseModule</code>、<code>UcenterModule</code>分别代表一般控件类、页面基类、用户中心基类。</p>
<ul>
<li>控件类是类似弹窗、toast等基本控件的继承类，封装了基本的控件类方法，包括控件的确定/取消按钮事件等。</li>
<li>页面基类是绝大部分页面的继承类，这里类中封装了页面的公共逻辑，比如显示头部导航栏/侧边栏/底部等，是几乎所有的页面都共享的逻辑，这里的逻辑，只要在特定页面中继承这个基类，可以做到公共业务逻辑的公用。</li>
<li>用户中心类是用户中心的特定类，除了函括大部分页面的公共逻辑之外还有专属的用户信息显示栏，所以<code>UcenterModule</code>是继承自<code>BaseModule</code>并封装了用户中心的统一处理逻辑，用户中心如果要新添加页面就只需要去继承<code>UcenterModule</code>这个类就好了。</li>
</ul>
<p>那么实际的代码大概是怎么样的呢？以下是简化的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> BaseComponent = klass(&#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//this is top initial</span></span><br><span class="line">    <span class="keyword">var</span> _data = options.data || &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.config &amp;&amp; <span class="keyword">this</span>.config(_data); <span class="comment">// 配置config参数</span></span><br><span class="line">    <span class="keyword">this</span>.baseComponentInit();</span><br><span class="line">  &#125;,</span><br><span class="line">  baseComponentInit: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//init baseComponent here</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> BaseModule = BaseComponent.extend(&#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.supr(options); <span class="comment">// call super initial function</span></span><br><span class="line">    <span class="keyword">this</span>.BaseModuleInit();</span><br><span class="line">  &#125;,</span><br><span class="line">  BaseModuleInit: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// init baseModele here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> UcenterModule = BaseComponent.extend(&#123;</span><br><span class="line">  initialize:<span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.supr(options);</span><br><span class="line">    <span class="keyword">this</span>.UcenterModuleInit();</span><br><span class="line">  &#125;,</span><br><span class="line">  UcenterModuleInit:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//init you UcentModule here</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>当我们要实现一个弹窗组件的时候，只需要<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Dialog = BaseComponent.extend(&#123;</span><br><span class="line">  initialize:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.supr();</span><br><span class="line">    <span class="comment">// initialize you code from here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>新键一个页面，只需要<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Page = BaseModule.extend(&#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.supr();</span><br><span class="line">    <span class="comment">// initialize you code from here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>新建一个用户中心页面，只需要<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> UcenterPage = UcentModule.extend(&#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.supr();</span><br><span class="line">    <span class="comment">// initialize you code from here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>看起来，基于oop(Object-oriented programming 面对对象程序设计)编程能够让我们将业务逻辑进行分层，通过抽象出可以复用的公共逻辑，并进行合理的分层就可以大大的提高我们的编码效率。<br><!-- <img class="klass.js-analyze/fenceng.png title:分层封装思想 extend:?imageView2/2/w/800"> –&gt;<br>分而治之，大概说的就是这个意思吧。<br>在分析源码之前，希望你能带着几个问题和我一同探索klass的实现:</p>
<ul>
<li>klass如何实现类的公共方法？</li>
<li>子类如何保证在初始化的时候对父类进行相应的初始化？</li>
<li>klass如何实现类的继承？</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><a href="https://github.com/ded/klass/blob/master/klass.js">klass未压缩版</a>的源码加上注释仅仅只有91行，但是实现起来会发现每一行都凝结了智慧的结晶。首先让我们看一下klass模块的封装</p>
<h3 id="klass模块封装"><a href="#klass模块封装" class="headerlink" title="klass模块封装"></a>klass模块封装</h3><p>klass模块是通过称之为UMD(Universal Module Definition 通用模块定义)的方式来实现的。具体来说就是一个IIFE(Immediately-invoked function expression 立即执行函数表达式）来暴露命名接口<code>klass</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">name, context, definition</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define == <span class="string">'function'</span>) define(definition); <span class="comment">// Amd</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> != <span class="string">'undefined'</span>) <span class="built_in">module</span>.exports = definition(); <span class="comment">// commonJS</span></span><br><span class="line">  <span class="keyword">else</span> context[name] = definition();</span><br><span class="line">&#125;(<span class="string">'klass'</span>, <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// klass 实现</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></p>
<p>前端模块化也是一个大家一致在讨论的问题，从全局函数满天飞到后面的基于AMD的requireJs到基于CMD的seaJS到基于Node的commonJs模块，到目前webpack打包一统天下的局面，前端模块化经历了几个时代的发展。UMD是一种通用模块定义方式，相对来说它不是一种标准而是一种更好兼容不同模块化环境的一种最佳体验，具体来说就是它会检测当前是否是作为AMD模块，如果不是检测是否是commonJS模块，都不是的话就暴露为context下的一个接口，在浏览器中<code>contenxt</code>通常就是<code>window</code>。</p>
<h3 id="三个函数"><a href="#三个函数" class="headerlink" title="三个函数"></a>三个函数</h3><p>上面我提到的三个问题还没忘记吧？现在我们来一个个的解答。不过在解答之前，先介绍源码中的基本函数/变量:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> context = <span class="keyword">this</span></span><br><span class="line">    , f = <span class="string">'function'</span> <span class="comment">// f代表 function 字符串</span></span><br><span class="line">    , fnTest = <span class="regexp">/xyz/</span>.test(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;xyz&#125;) ? <span class="regexp">/\bsupr\b/</span> : <span class="regexp">/.*/</span> <span class="comment">// fnText 测试方法是否为类入口函数</span></span><br><span class="line">    , proto = <span class="string">'prototype'</span>; <span class="comment">// prototype的字符串 用于通过a.[proto]动态求值属性</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFn</span>(<span class="params">o</span>) </span>&#123; <span class="comment">// 判断o是否是函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> o === f</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="process函数"><a href="#process函数" class="headerlink" title="process函数"></a>process函数</h4><p>解答问题：klass如何实现类的公共方法？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">what, o, supr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> o) &#123;</span><br><span class="line">      <span class="keyword">if</span> (o.hasOwnProperty(k)) &#123;</span><br><span class="line">        what[k] = isFn(o[k]) <span class="comment">// 这里的3目运算符是为了判断在子类源对象（即o中）的入口函数是哪个 </span></span><br><span class="line">          &amp;&amp; isFn(supr[proto][k]) <span class="comment">// 通常入口函数名所有类都保持一致，就像最上面的initialize方法</span></span><br><span class="line">          &amp;&amp; fnTest.test(o[k]) <span class="comment">// 也要测试子类入口函数中是否显示的调用父类 e.g.上面在initialize方法中调用 this.supr()</span></span><br><span class="line">          ? wrap(k, o[k], supr) : o[k] <span class="comment">// 如果使满足条件的入口方法就通过wrap函数包裹住，否则直接将属性赋值到原型对象上</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的函数是用来处理将方法/属性动态添加到构造函数原型/实例对象上的。<br>调用的时候像下面这样使用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">process(proto, o, <span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// proto === 父类原型  o === 子类继承父类传递到extend()里面或klass里面的包含各种类方法的对象</span></span><br></pre></td></tr></table></figure></p>
<p>通过调用上面的<code>process</code>函数就可以很方便的实现子类原型上属性/方法的正确设置。</p>
<h3 id="wrap函数"><a href="#wrap函数" class="headerlink" title="wrap函数"></a>wrap函数</h3><p>解答问题：子类如何保证在初始化的时候对父类进行相应的初始化？<br>我们知道在使用klass创建的类中有都有一个默认入口方法，这个入口方法的作用就是初始化该类封装的公共逻辑，那么klass是如何保证在子类中的入口函数中调用<code>this.super()</code>就可以初始化他的上层/上上层父类中封装的逻辑呢？答案就是：闭包。我们来看下面的wrap函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrap</span>(<span class="params">k, fn, supr</span>) </span>&#123; <span class="comment">// 入口函数的包裹  k代表入口函数key  fn代表入口函数 supr代表父类构造函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="keyword">this</span>.supr; <span class="comment">// 暂存this实例上的supr属性</span></span><br><span class="line">    <span class="keyword">this</span>.supr = supr[proto][k]; <span class="comment">//supr.prototype.initialize 将父类原型上的入口函数赋值给实例的supr属性</span></span><br><span class="line">    <span class="keyword">var</span> undef = &#123;&#125;.fabricatedUndefined; <span class="comment">// 保证undef 真的等于 undefined  获取空对象不存在的属性会返回"undefined"</span></span><br><span class="line">    <span class="keyword">var</span> ret = undef; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ret = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用入口函数绑定this并传入参数</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.supr = tmp; <span class="comment">// 将this实例上的supr属性赋值回来</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret <span class="comment">// 返回入口函数运行的结果</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的<code>process</code>函数的作用有两个：</p>
<ul>
<li>一个是将相关的属性加载到原型对象/构造函数对象上</li>
<li>找到类的入口函数，并将它包裹一层闭包返回。（这是保证了子类上调用<code>this.supr</code>的调用顺序，一定会指向上一层父类的入口函数而不是上上层超父类的入口函数，希望你没有忘记访问原型链中属性的同名遮蔽效应！）</li>
</ul>
<h3 id="extend函数"><a href="#extend函数" class="headerlink" title="extend函数"></a>extend函数</h3><p>回答：klass如何实现类的继承？==&gt; 通过<code>extend</code>函数来实现类继承。<br>我们知道在ES5中，继承的实质是通过将子类的原型对象设置为父类的实例来完成的，klass也不例外。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">o, fromSub</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// must redefine noop each time so it doesn't inherit from previous arbitrary classes</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">noop</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    noop[proto] = <span class="keyword">this</span>[proto] <span class="comment">// 使用空函数作为中介实现原型继承</span></span><br><span class="line">    <span class="keyword">var</span> supr = <span class="keyword">this</span> <span class="comment">// 保存父类</span></span><br><span class="line">      , prototype = <span class="keyword">new</span> noop() <span class="comment">// 对象指向noop.prototype</span></span><br><span class="line">      , isFunction = isFn(o)</span><br><span class="line">      , _constructor = isFunction ? o : <span class="keyword">this</span> <span class="comment">// 判断构造函数</span></span><br><span class="line">      , _methods = isFunction ? &#123;&#125; : o <span class="comment">// 方法 如果是函数则返回空的字面量对象 否则将包含各种方法的对象赋值给_methods</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.initialize) <span class="keyword">this</span>.initialize.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 借用initialize作为构造函数</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        fromSub || isFunction &amp;&amp; supr.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 另外一种形式调用则自动调用父类</span></span><br><span class="line">        _constructor.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用子类的构造函数</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn.methods = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">      process(prototype, o, supr); <span class="comment">// 将方法复制到原型上</span></span><br><span class="line">      fn[proto] = prototype; <span class="comment">// 设置正确的原型</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 返回this实现链式调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn.methods.call(fn, _methods).prototype.constructor = fn;  <span class="comment">// 修正constructor</span></span><br><span class="line"></span><br><span class="line">    fn.extend = <span class="built_in">arguments</span>.callee;  <span class="comment">// 递归回调</span></span><br><span class="line">    fn[proto].implement = fn.statics = <span class="function"><span class="keyword">function</span> (<span class="params">o, optFn</span>) </span>&#123; <span class="comment">// 提供复写原型对象/构造函数上属性的方法</span></span><br><span class="line">      o = <span class="keyword">typeof</span> o == <span class="string">'string'</span> ? (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">// 如果o是属性名字 就包装成对象&#123;key: value&#125;形式</span></span><br><span class="line">        <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">        obj[o] = optFn;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">      &#125;()) : o</span><br><span class="line">      process(<span class="keyword">this</span>, o, supr); <span class="comment">// 将o对象的方法赋值到this中 当通过Constructor.statics调用this指的是constructor</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;            <span class="comment">// 接上面：当Constructor.prototype.statics this指的是Constructor.prototype</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fn; <span class="comment">//返回真正的构造函数！</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的<code>extend</code>函数后面有加上我的注释，可以照着代码多看看，如果有错误欢迎指正～，这里简单说下<code>extend</code>函数的大致流程：</p>
<ul>
<li>首先初始化并赋值必要的变量</li>
<li>声明真实的构造函数<code>fn</code>，并为构造函数设置正确的原型链，修正原型对象上的constructor</li>
<li>给<code>fn</code>添加<code>extend</code>方法，来让子类递归调用<code>extend</code>实现层层继承</li>
<li>给<code>fn</code>添加<code>statics</code>、<code>fn.prototpue</code>添加<code>implement</code>方法实现对象属性的覆写</li>
<li>返回<code>fn</code>函数</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这里来做个小的总结：<br>1、为什么要使用oop？答：因为可以更直观的以传统面对对象方式来编程，对于大多数程序员来说理解起来不会费劲。<br>2、通过将类进行拆分，将公共的逻辑进行封装，可以有效的提升开发效率。</p>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul>
<li>klass虽然用着还不错，在通读其源码之后要好好的利用他的优势，避免不利点。Javascript中实现类继承的实质就是通过延长<code>_proto_</code>原型链来完成的，这样造成的查找可能会存在一些同名遮蔽效应带来的问题。举个例子来说：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = klass(&#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">  &#125;,</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Say hello from Person!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> Asian = Person.extend(&#123;</span><br><span class="line">  initialize:<span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.supr(options); <span class="comment">// this.supr ==&gt; supr.prototype.initialize  supr 通过闭包保证了正确的指向</span></span><br><span class="line">    <span class="keyword">this</span>.init(options);</span><br><span class="line">  &#125;,</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Say hello from Asian!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Chinese = Asian.extend(&#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.supr(options);</span><br><span class="line">    <span class="keyword">this</span>.init(options);</span><br><span class="line">  &#125;,</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Say hello from Chinese!"</span>); <span class="comment">// Say hello from Chinese! *3!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Chinese(&#123;</span><br><span class="line">  data: <span class="string">"From china!"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的代码相信你可以看出问题来，在实例化<code>Chinese</code>的时候，他会执行入口函数<code>initialize</code>，在<code>initialize</code>函数中呢，klass通过<code>wrap</code>函数将<code>supr</code>(父类构造函数)包裹在闭包中来保证<code>this.supr</code>一定指向<code>Asian.initialize</code>，同理在<code>Asian.initialize</code>中的<code>this.supr</code>指向的是<code>Person.initialize</code>。以此来实现在<code>new Chinese()</code>的时候由继承的顺序分别调用父类的<code>initialize</code>入口方法。但是在<code>Chinese,Asian,Person</code>的入口函数中调用的<code>init</code>方法本想着调用该类的<code>init</code>方法，但是由于javascript原型链的机制，查找<code>init</code>属性的顺序会是<code>Chinese.proptotype</code>=&gt;<code>Asian.prototype</code>=&gt;<code>Person.prototype</code>所以调用的<code>init</code>是<code>Chinese</code>类上的方法，这个问题是由于javascript的原型链造成的，我们应该知道这个可能存在的问题并且极力避免他。</p>
<p>如有错误，欢迎留言指正。</p>
--></p></div></article></div><div class="paginator clearfix"><a href="/2017/02/08/nodejs-fs/" class="prev">上一篇</a><a href="/2017/01/08/javascript/react-family-one/" class="next">下一篇</a></div></section><section class="footer"><div class="copyright">©2015-2019 <a href="/about/index.html">Simmer</a> | Front-ender | Amateur photographer. </div><div id="go-pg-top" style="display: none; opacity: 0.6;" title="返回顶部">TOP</div></section></div></div><script src="/js/jquery-1.11.1.js"></script><script src="/js/common.js"></script></script></body></html>