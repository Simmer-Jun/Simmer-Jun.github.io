<!DOCTYPE html><html class="no-js"><head><meta charset="utf-8"><title>司马-Simmer-React全家桶－当使用React新建一个页面的时候我都在思考什么？(三)</title><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.icon"><link rel="stylesheet" href="/css/style.css"><!-- detech broser's env --><script src="/js/modernizr.js" type="text/javascript"></script><meta name="description" content="A Blog Powered By Hexo"></head><body><div class="nav clearfix nav-show"><div title="隐藏导航" id="nav-btn" class="nav-guide"><i class="icon nav-icon">&#xe603;</i></div><div class="nav-inner  clearfix"><a href="/" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe606;</div><span>Home</span></div></a><a href="/archives" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe602;</div><span>Archives</span></div></a><a href="/photography" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe604;</div><span>摄影</span></div></a><a href="/tags" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe601;</div><span>Tags</span></div></a><a href="/about" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe605;</div><span>About</span></div></a></div></div><div class="wraper"><div class="main"><section class="content"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2017/05/11/javascript/react/what-i'm-thinking-when-writing-newpage-using-React/" class="post-title-link">React全家桶－当使用React新建一个页面的时候我都在思考什么？(三)</a></h2><div class="post-subtitle clearfix"><span class="post-date">2017年5月11日</span><div class="post-tag"><a href="/2017/05/11/javascript/react/what-i'm-thinking-when-writing-newpage-using-React/"><sapn>JavaScript</sapn><i class="icon">&#xe600;</i></a><a href="/2017/05/11/javascript/react/what-i'm-thinking-when-writing-newpage-using-React/"><sapn>React</sapn><i class="icon">&#xe600;</i></a></div></div><div class="post-content"><p>React作为构建用户界面的前端库(View Library)，现在已经成为各大公司的技术栈一员，我们组内也早已着手基于React来构建项目，有幸从零开始开发了一些页面，有了一些自己的想法。当使用React来构建一个web页面的时候，我都在思考什么？<br>这里仅以一个简单的web page为栗，暂且抛开使用Reat-router或Redux的单页应用不说。</p>
<img title="React.js" src="http://oiwdpm2o1.bkt.clouddn.com/static/images/what-I-am-thinking-when/img-1.jpg?imageView2/2/w/600">
<a id="more"></a>
<h2 id="gai-lan"><a href="#概览" class="headerlink" title="概览"></a>概览<a href="gai-lan" class="header-anchor">"#"</a></h2><ul>
<li>前言：组件之间的通信</li>
<li>抽象state(数据流的清晰)</li>
<li>抽取组件(组件划分结构合理，高可复用性)</li>
<li>实现组件(组件类型？实现细节？规范？极端情况处理)</li>
<li>各司其职(React能与不能)</li>
<li>性能优化(shouldComponentUpdate)</li>
<li>还能做些什么？</li>
</ul>
<p>注：原则上建立在数据(state)存放在顶层组件管理，由props将数据层层传递到底层组件，这样做的好处是逻辑上利于分析，数据流保持相应的清晰，也能够保证底层子组件最大程度的复用(后面会说到)</p>
<h2 id="qian-yan-zu-jian-zhi-jian-de-tong-xin"><a href="#前言：组件之间的通信" class="headerlink" title="前言：组件之间的通信"></a>前言：组件之间的通信<a href="qian-yan-zu-jian-zhi-jian-de-tong-xin" class="header-anchor">"#"</a></h2><p>React中并没有类似Angular中的双向绑定功能，所以在开始之前，让我们先探讨一下React组件之间的通信。<br><img title="React-component-data-flow.js" src="http://oiwdpm2o1.bkt.clouddn.com/static/images/what-I-am-thinking-when/data-flow.png?imageView2/2/w/800"></p>
<p>上图中，<code>container</code>作为顶层组件，管理着全局state，然后通过<code>props</code>层层传递给子组件A、B，B组件再通过<code>props</code>将数据传递给它的子组件C、D，子组件A、B、C、D的相关的业务逻辑处理也可以通过<code>this.props.onHandleXXX</code>的方式层层传递到顶层组件执行，既保持了底层组件的灵活性(只关心render)，也保证了业务逻辑上的解耦(业务逻辑统一在container中进行处理)。<br>关于组件之间的通信，总结来说无非就这几种情况，以上图为例：</p>
<ul>
<li><p>父组件与子组件之间的通信，通信是一个相互的概念，父组件与子组件通信通过props来完成，子组件与父组件通信通过<code>this.props.onHandleXXX</code>执行父组件的回调来完成通信的。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ComponentB <span class="keyword">from</span> <span class="string">'/component/xxx/componentB'</span>;</div><div class="line"><span class="comment">// container component</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props)&#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.handleXXX = <span class="keyword">this</span>.handleXXX.bind(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">  render()&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className="wraper"&gt;</div><div class="line">        &lt;ComponentB</div><div class="line">          data = &#123;this.props.data&#125;</div><div class="line">          onHandleXXX = &#123;this.handleXXX&#125;</div><div class="line">        /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">      );</div><div class="line">  &#125;,</div><div class="line">  handleXXX()&#123;</div><div class="line">    console.log('ComponentB communicate with me!');</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>兄弟组件之间的通信类似<code>ComponentA &lt;==&gt; ComponentC | ComponentC &lt;==&gt; ComponentD</code>这种，可以通过抽象出具体的<code>state</code>放在离他们之上的‘最近’的公共组件来实现（对于A&lt;==&gt;B，这个组件是<code>Container</code>，对于C&lt;==&gt;D，这个组件可以是<code>ComponentB</code>也可以是<code>Container</code>），我的建议是视具体的业务逻辑来看，如果这个抽象的<code>state</code>只有<code>ComponentC</code>和<code>ComponentD</code>需要，则大可放在<code>ComponentB</code>中进行管理，减少顶层组件不必要的<code>state</code>及由于<code>C｜D</code>组件通信可能造成的其他组件(例如<code>ComponentA</code>)不必要的更新。但是对这个<code>state</code>来说，如果<code>ComponentA</code>也需要的话统一放到最顶层<code>Container</code>中反而会更好。</p>
</li>
<li>祖孙组件之间的通信，类似<code>Container&lt;==&gt;ComponentC | Container&lt;==&gt;ComponentD</code>，这种跨组件的通信，统一使用props来进行逐级传递，可以类似为父子组件的通信，只不过在祖孙组件之间的组件充当的是‘接力’<code>props</code>的工作，本质上不会对props进行处理。</li>
</ul>
<h2 id="chou-xiang-state"><a href="#抽象state" class="headerlink" title="抽象state"></a>抽象state<a href="chou-xiang-state" class="header-anchor">"#"</a></h2><p>可以将React看作状态机，用户的不同交互行为触发了不同的组件回调，组件的状态也会随着改变。得益于React的<code>state</code>，我们仅仅需要告诉React何时改变<code>state</code>，描述组件输入不同数据的UI表现，React会帮我们更新<code>state</code>，重新渲染视图。</p>
<img title="React-action-view" src="http://oiwdpm2o1.bkt.clouddn.com/static/images/what-I-am-thinking-when/img-2.jpg?imageView2/2/w/800">
<p>React更新视图的时机可能是用户触发的一个交互行为，也可能是代码主动触发的<code>setState</code>(比如说一个倒计时组件，当倒计时结束时，会通过回调来告知父组件倒计时结束，父组件在进行相应的逻辑处理)，可以将这个<code>setState</code>的动作放在发生交互的组件，也可以放在父组件，也可以放在祖组件，具体的存放位置要已具体的业务逻辑或组件拆分策略来进行划分。</p>
<p>应该保证state的最简性，一些可以通过其他<code>state</code>计算出来的数据没有必要放到state中，这样只会增加组件维护的复杂性。举一个简单的栗子：</p>
<img title="tabList" src="http://oiwdpm2o1.bkt.clouddn.com/static/images/what-I-am-thinking-when/img-6.jpg?imageView2/2/w/800">
<p>上图是一个简单的tab组件，切换不同的tab展示不同的内容。这个<code>tab</code>组件的数据是一个列表，看起来可能会是这样的：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tabList = [</div><div class="line">  &#123;</div><div class="line">    tabType: <span class="number">1</span>,</div><div class="line">    tabName:<span class="string">'最新动态'</span></div><div class="line">  &#125;,&#123;</div><div class="line">    tabType: <span class="number">2</span>,</div><div class="line">    tabName:<span class="string">'好友圈'</span></div><div class="line">  &#125;,&#123;</div><div class="line">    tabType: <span class="number">3</span>,</div><div class="line">    tabName:<span class="string">'特别关注'</span></div><div class="line">  &#125;</div><div class="line">];</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">tabList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props)&#123;</div><div class="line">    <span class="keyword">super</span>(props)</div><div class="line">  &#125;</div><div class="line">  handleChangeTab(activeType)&#123;</div><div class="line">    <span class="keyword">var</span> tabMap = &#123;</div><div class="line">      <span class="string">'1'</span>: <span class="string">'最新动态'</span>,</div><div class="line">      <span class="string">'2'</span>: <span class="string">'好友圈'</span>,</div><div class="line">      <span class="string">'3'</span>: <span class="string">'特别关注'</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;</div><div class="line">      tabType: activeType,</div><div class="line">      tabName: tabMap[activeType]</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  render()&#123;</div><div class="line">    &lt;div className="m-tab"&gt;</div><div class="line">      &#123;this.props.tabList.map((item, index) =&gt; &#123;</div><div class="line">        if(item.tabType === this.state.tabType)&#123;</div><div class="line">          return (</div><div class="line">            &lt;div className=&#123;'item active'&#125; onClick=&#123;(item.type) =&gt; this.handleChangeTab(item.type)&#125;&gt;&#123;this.state.tabName&#125;&lt;/div&gt;</div><div class="line">          );</div><div class="line">        &#125;</div><div class="line">        return (</div><div class="line">          &lt;div className="item" onClick=&#123;(item.type) =&gt; this.handleChangeTab(item.type)&#125;&gt;&#123;item.tabName&#125;&lt;/div&gt;</div><div class="line">        );</div><div class="line">      &#125;)&#125;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个栗子可能不是很恰当，只是为了表达我的意思，像上面这样，将当前active的<code>tabType</code>和<code>tabName</code>都存在<code>state</code>中就没必要，只需要存其中一个就可以，我们完全可以通过计算获取另一个的值。所以，尽量保证组件<code>state</code>的简洁。</p>
<h2 id="chou-qu-zu-jian"><a href="#抽取组件" class="headerlink" title="抽取组件"></a>抽取组件<a href="chou-qu-zu-jian" class="header-anchor">"#"</a></h2><h3 id="zu-jian-zu-he-ben-zhi"><a href="#组件组合本质" class="headerlink" title="组件组合本质"></a>组件组合本质<a href="zu-jian-zu-he-ben-zhi" class="header-anchor">"#"</a></h3><p>React中的组件的渲染是以一种递归的方式来进行的，实际上组件的展现形式就是通过层层的嵌套来完成的。<br><img title="React组件嵌套" src="http://oiwdpm2o1.bkt.clouddn.com/static/images/what-I-am-thinking-when/img3.jpg?imageView2/2/w/800"><br>每个组件都有一个包含所有需要渲染组件的<code>Container</code>组件，在React中，可以通过<code>ReactDOM.render</code>来将这个<code>Container</code>组件挂载渲染，剩下的事情，就交给React的递归渲染来帮我们完成。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> Container <span class="keyword">from</span> <span class="string">'../xx/Container.jsx'</span>;</div><div class="line"><span class="comment">//略</span></div><div class="line"> ReactDOM.render(&lt;Container/&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'Container'</span>));</div></pre></td></tr></table></figure></p>
<h3 id="zu-jian-fen-lei"><a href="#组件分类" class="headerlink" title="组件分类"></a>组件分类<a href="zu-jian-fen-lei" class="header-anchor">"#"</a></h3><p>看起来组件的拆分是一个比较重要的点，如何拆，拆的力度如何这都需要思考。根据组件的业务通用类型，我将组件划分为3种类型：</p>
<ul>
<li>通用组件，这类组件是很基础的组件，类似一个输入框，一个下拉选择框等，这类组件没有包含任何业务逻辑，可以在任何有需要的业务逻辑中被复用，仅仅包含简单的UI展示和简单的交互逻辑，而交互逻辑是可以通过回调来传递上层组件处理的。</li>
<li>业务复用组件，这类组件的核心是，只专注与在某一类特定的业务中，所以它需要考量的点是如何更好在某一类型的组件中被复用。</li>
<li>特定业务组件，这类组件包含了特定的业务逻辑，从复用的层面看几乎没法用到其他的业务中，对于这类组件来说，它们关注的点应该是特定的业务如何更好的划分和组织。通常我都会给这类组件取名如<code>xxxWraper</code>｜<code>Container</code>等，表达的意思也很清晰，就是一个外包组件｜顶层组件。如下图所示<img title="React组件嵌套" src="http://oiwdpm2o1.bkt.clouddn.com/static/images/what-I-am-thinking-when/img-5.jpg?imageView2/2/w/800">
</li>
</ul>
<h3 id="fu-yong"><a href="#复用" class="headerlink" title="复用"></a>复用<a href="fu-yong" class="header-anchor">"#"</a></h3><p>复用，一定程度上指的是高可配置，能够通过传递不同的配置参数涵盖不同的业务场景。<br>相信每一个工程师都不会把时间浪费在1+1上面，组件的复用一方面能够解放工程师的劳动力，另一方面能够真正的从工程化的角度去看待软件工程问题。<br>上图中，<code>componentA</code>被复用在不同地方，这主要得益于以下几点：</p>
<ul>
<li><code>componentA</code>不包含业务代码，或者只包含通用的业务代码(对于业务复用组件来说)，它们仅仅负责接受数据，然后<code>return View</code>。</li>
<li>用户的交互都可以通过<code>this.props.onHandleXXX</code>来交给不同的<code>Wraper</code>来处理，真正做到剥离‘数据’和‘行为’。</li>
</ul>
<p>拿到一个新的页面，我们可以先根据页面的组成结构将组件进行初步划分，例如<code>Header</code>|<code>Body</code>|<code>sideContent</code>|<code>Footer</code>，接着们对每一个结构组件中的组件再次细分。这个时候需要思考：</p>
<ul>
<li>思考哪些组件是可以直接复用的：<code>Header</code>和<code>Footer</code>组件是可以复用的，无须重复编写，我们只需要查看这些组件编写者的注释，按照要求传递相应的<code>props</code>即可，<code>Body</code>中可能还有一个分页功能，这个功能也是已有的组件，可以直接使用，但要注意组件的配置参数。</li>
<li>思考哪些组件是可能被复用的：<code>Body</code>里面可能包含<code>Item</code>，这个<code>Item</code>可能会在其他页面中使用到，所以要在编写<code>Item</code>的时候注意尽量写成通用的，尽可能兼容可能出现的场景(通过<code>defaultProps</code>来处理)</li>
<li>思考哪些组件是<code>wraper组件</code>，需要包含特定的业务逻辑，如何清晰有效的规划这些逻辑。</li>
</ul>
<h2 id="shi-xian-zu-jian"><a href="#实现组件" class="headerlink" title="实现组件"></a>实现组件<a href="shi-xian-zu-jian" class="header-anchor">"#"</a></h2><p>当将业务理顺了之后，尽量保持简洁的情况下抽象出整个page需要的<code>state</code>，根据组件的类型将组件进行划分，一些组件的划分是否合理性，可能要等到开发的时候才能意识到，不过这是正常的情况，随着业务的变更，势必会对现有的组件重新划分，所以在开发前势必要保证一定的‘前瞻性’。</p>
<h3 id="zu-jian-lei-xing"><a href="#组件类型" class="headerlink" title="组件类型"></a>组件类型<a href="zu-jian-lei-xing" class="header-anchor">"#"</a></h3><p>React组件按照有无state可以分为以下几类：</p>
<ul>
<li>Functional-Component (函数组件，无状态，无生命周期函数)</li>
<li>Class-Component (使用<code>React.createClss</code>API或者继承自<code>React.Component</code>的类，可以有state和生命周期函数)</li>
</ul>
<p>但是按照React官方说法，未来将会考虑为<code>Functional-Component</code>引入<code>state</code>，这样以来，组件的分类可能要变为下面这样：</p>
<ul>
<li>Functional-Component</li>
<li>stateLess-Functional-Component</li>
<li>stateLess-Component</li>
<li>Class Component<br>所以到底使用<code>Functional-Component</code> 还是<code>class xxx extends React.Component</code>创建的component，是我们需要考虑的。<br>函数组件没有周期函数和<code>state</code>，看起来十分简洁，一些存文案展示的组件或者一些中间件组件(例如一个<code>itemList组件</code>，仅仅负责遍历渲染<code>item</code>，没有其他逻辑，但是一些情况下我们需要使用生命周期函数的情况下则是不得不使用传统的<code>Component</code>，比如需要在在列表DOM渲染完毕后，对相关的DOM进行操作，就需要使用<code>componentDidMount</code>或者<code>componentDidUpdat</code>方法)</li>
</ul>
<h3 id="zu-jian-gui-fan"><a href="#组件规范" class="headerlink" title="组件规范"></a>组件规范<a href="zu-jian-gui-fan" class="header-anchor">"#"</a></h3><p>一个人的项目可以随意编写代码，但是放到一个团队中则需要统一编码规范。否则，1+1&lt;2是很正常的事情，如果没有统一规范，你会发现做了很多重复劳动，组件的规范包括但不限于：</p>
<ul>
<li>组件头部的注释，组件功能概述｜作者｜编写日期｜需要传入的props(哪些是必须的，哪些是可选的)</li>
<li>组件的回调规范，在组件内部处理的事件处理函数，统一命名为<code>handleXXX</code>，传入组件的回调props命名为<code>onHandleXXX</code></li>
<li>组件的类名规范，模块以<code>m-</code>开头，组件以<code>w-</code>等等</li>
<li>组件的<code>ajax</code>获取时机，初始化在<code>componentDidMount</code>，关于为什么不建议在<code>componentWillMount</code>中进行<code>ajax</code>请求，可以<a href="http://stackoverflow.com/questions/27139366/why-do-the-react-docs-recommend-doing-ajax-in-componentdidmount-not-componentwi" target="_blank" rel="external">看这里</a>和<a href="http://stackoverflow.com/questions/39363583/reactjs-ajax-call-in-componentwillmount" target="_blank" rel="external">这里</a>)</li>
<li>组件内函数的参数注释，对组件内的各个方法，需要标注参数类型</li>
<li>保持<code>render</code>函数的纯，仅仅负责描述<code>Virtual DOM</code></li>
<li>其他规范</li>
</ul>
<h2 id="ge-si-qi-zhi"><a href="#各司其职" class="headerlink" title="各司其职"></a>各司其职<a href="ge-si-qi-zhi" class="header-anchor">"#"</a></h2><p>在选取框架/库的角度，衡量的标准是不一致的，每个框架/库都有它所擅长的一面，大部分场景下React表现可能十分出色，但是在某些特殊场景下，使用React就显得不那么有优势，在编写组件的时候，不能完全要想着使用React来完成业务需求，当使用React实现起来比较繁盛/损耗性能的时候，要敢于跳出React的既定圈子，尝试使用<code>jQuery</code>或许会更好。</p>
<h2 id="xing-neng-you-hua"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化<a href="xing-neng-you-hua" class="header-anchor">"#"</a></h2><p>追求页面打开的极致是每一个前端工程师的追求，React高效的diff算法虽然已经减少了许多不必要的真实DOM操作，但是我们依旧需要避免一些无意义的重复渲染，这其中的关键点是<code>shouldComponentUpdate</code>函数，告知接下来的<code>props</code>和<code>state</code>，如果无须更新，可以在<code>shouldComponentUpdate</code>中返回<code>false</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 略</span></div><div class="line">  shouldComponentUpdate: <span class="function"><span class="keyword">function</span>(<span class="params">nextProps, nextState</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(nextPros.a.b === <span class="keyword">this</span>.props.a.b || nextState.c.d === <span class="keyword">this</span>.state.c.d)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>就这么简单，如果判断无须更新，我们仅需返回<code>false</code>即可，说到这里又牵扯出了如何判断<code>props</code>和<code>state</code>的问题上。如果是判断基本的类型还好，可以保证达到我们想要的效果。但是如果我们要判断的是对象的话就会有问题了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.state.arr = [<span class="number">1</span>,<span class="number">2</span>];</div><div class="line"><span class="keyword">this</span>.state.arr.push(<span class="number">3</span>);</div><div class="line"><span class="keyword">this</span>.setState(&#123;</div><div class="line">  arr: <span class="keyword">this</span>.state.arr</div><div class="line">&#125;)</div><div class="line"><span class="comment">//</span></div><div class="line">shouldComponentUpdate: <span class="function"><span class="keyword">function</span>(<span class="params">nextProps, nextState</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(nextState.arr === <span class="keyword">this</span>.state.arr)&#123;<span class="comment">// error! 永远相等</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果比较的是引用类型，其实真正判断的是指向的引用是否相等，但是还好，我们可以使用FaceBook推出的<a href="https://facebook.github.io/immutable-js/" target="_blank" rel="external">immutable.js</a>，这个库的核心思想就是对于相同对象的修改返回不同的引用，这样就很好的解决了上面判断错误的情况。</p>
<h2 id="huan-neng-zuo-xie-shi-me"><a href="#还能做些什么？" class="headerlink" title="还能做些什么？"></a>还能做些什么？<a href="huan-neng-zuo-xie-shi-me" class="header-anchor">"#"</a></h2><ul>
<li>特殊情况处理(列表为空|ajax数据获取异常)</li>
<li>抽象后端接口，后端传来的数据接口不一定完全满足前端展示需要，某些情况下，需要通过一个<code>wraper</code>组件将数据转化为符合组件展示需求的格式</li>
<li>propType校验 | chrome DevToll测试页面渲染更新性能</li>
<li>回顾组件的整体数据流，找到可能阻塞性能的地方(警惕<code>setState</code>这个动作，它可能会导致该组件及其子组件的递归更新，进而触发它或子组件的<code>componentWillReceiveProps</code>|<code>componentDidUpdat</code>等方法，而这些方法都是可能潜在运行一些逻辑代码的地方)</li>
<li>回顾<code>componentWillUnmount</code>方法，别忘了在这里注销通过第三方注册的事件handle!</li>
<li>HOC(Hight-Order-Component)，如何结合高阶组件来使用，让你的组件更加的通用和flexible.</li>
<li>业务复杂时是否要引入状态管理库－Redux|Reflux..etc</li>
<li>组件测试</li>
<li>…</li>
</ul>
<h2 id="zong-jie"><a href="#总结" class="headerlink" title="总结"></a>总结<a href="zong-jie" class="header-anchor">"#"</a></h2><p>在新建一个页面的时候，需要由浅入深的考虑组件划分，总是免不了抽组件这个话题，从何种维度抽，以何种标准抽，这都没有一个固定的答案，要依据组内的规范，业务的需求来衡量。也不需要对划分组件很担忧，当你以一个标准划分之后，随着业务的发展，自然而然的就会知道组件分的合不合理，心中对于组件的划分也就会逐级清晰起来，这是一个过程，需要我们不断的自我反思和总结。<br>当你从仅仅为了应付需求而简单的完成一个页面，到能够使用一种更为工程化的角度去看待页面时，我想说：你好，前端工程师！</p>
</div></article></div><div class="paginator clearfix"><a href="/2017/04/23/photography/helloPhotography/" class="next">下一篇</a></div></section><section class="footer"><div>Host By Github Pages | Thans For Coming | Hexo Theme <a href="https://github.com/Simmer-Jun/hexo-theme-grace">Grace</a></div><div class="copyright">© 2017 <a href="/about/index.html">Simmer</a>. All rights reserved.</div><div id="go-pg-top" style="display: none; opacity: 0.6;" title="返回顶部">TOP</div></section></div></div><script src="/js/jquery-1.11.1.js"></script><script src="/js/common.js"></script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1257488449' class='cnzz'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1257488449%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></body></html>