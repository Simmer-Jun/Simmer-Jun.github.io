<!DOCTYPE html><html class="no-js"><head><meta charset="utf-8"><title>司马-Simmer-React全家桶－揭秘setState(二)</title><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.icon"><link rel="stylesheet" href="/css/style.css"><!-- detech broser's env --><script src="/js/modernizr.js" type="text/javascript"></script><meta name="description" content="A Blog Powered By Hexo"></head><body><div class="nav clearfix"><div title="隐藏导航" id="nav-btn" class="nav-guide"><i class="icon nav-icon">&#xe603;</i></div><div class="nav-inner  clearfix "><a href="/" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe606;</div><span>Home</span></div></a><a href="/archives" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe602;</div><span>Archives</span></div></a><a href="/photography" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe604;</div><span>摄影</span></div></a><a href="/tags" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe601;</div><span>Tags</span></div></a><a href="/about" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe605;</div><span>About</span></div></a></div></div><div class="wraper"><div class="main"><section class="content"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2017/03/12/javascript/react/ReactsetState/" class="post-title-link">React全家桶－揭秘setState(二)</a></h2><div class="post-subtitle clearfix"><span class="post-date">2017年3月12日</span><div class="post-tag"><a href="/2017/03/12/javascript/react/ReactsetState/"><sapn>React</sapn><i class="icon">&#xe600;</i></a></div></div><div class="post-content"><p>谈到React，不得不提到的就是<code>state</code>，相信你一定用过很多次的<code>setState</code>，也知道<code>setState</code>是一个异步方法，正如官网说的：</p>
<blockquote>
<p>setState() does not immediately mutate this.state but creates a pending state transition. Accessing this.state after calling this method can potentially return the existing value.<br>There is no guarantee of synchronous operation of calls to setState and calls may be batched for performance gains.</p>
</blockquote>
<a id="more"></a>
<h2><span id="setstate调用位置">setState调用位置</span></h2><p>从React调用stateState的位置来看情况无非有2种:</p>
<ul>
<li>一种是在生命周期函数中 <code>componentWillMount</code>、<code>componentDidMount</code>、<code>componentWillReceiveProps</code>、<code>render</code>等</li>
<li>在各种handler中(包括组件本身元素的handler和通过this.props.handerXXX)</li>
</ul>
<h3><span id="在handler中setstate">在handler中setState</span></h3><p>思考以下代码运行结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.clickHandler = <span class="keyword">this</span>.clickHandler.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  clickHandler()&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"log 1 :"</span>, <span class="keyword">this</span>.state.count); <span class="comment">// log 1</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"log 2 :"</span>, <span class="keyword">this</span>.state.count); <span class="comment">// log 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;Count: &#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.clickHandler&#125;&gt;Count Add&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>试着想一下当点击button的时候2次log的结果分别是什么？先不急着公布答案，在来看看下面的代码</p>
<h3><span id="在生命周期中setstate">在生命周期中setState</span></h3><p>再次思考以下代码运行结果<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillMount()&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"log 3 :"</span>, <span class="keyword">this</span>.state.count); <span class="comment">// log 3</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"log 4 :"</span>, <span class="keyword">this</span>.state.count); <span class="comment">// log 4</span></span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;Count: &#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你一定知道在<code>componentWillMount</code>调用<code>setState</code>是会合并state而不会触发re-render，那么log3和log4分别输出多少呢？</p>
<h2><span id="setstate调用方式">setState调用方式</span></h2><p>众所周知，在JavaScript中充满了各种异步函数，当然<code>setState</code>也可以被异步调用，再来思考下面的代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillMount()&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"log 5 :"</span>, <span class="keyword">this</span>.state.count); <span class="comment">// log 5</span></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"log 6 :"</span>, <span class="keyword">this</span>.state.count); <span class="comment">// log 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;Count: &#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的<code>setState</code>是被放入异步执行队列被执行的，那么log5和log6分别输出多少呢？(在各种handler回调中执行的异步setState类似这里的5和6)</p>
<h2><span id="答案">答案</span></h2><p>log1和log2<br><img title="setState_01" src="http://oiwdpm2o1.bkt.clouddn.com/static/images/react/setState_01.jpg?imageView2/1/w/770/h/500"><br>log3和log4<br><img title="setState_01" src="http://oiwdpm2o1.bkt.clouddn.com/static/images/react/setState_02.jpg?imageView2/1/w/770/h/500"><br>log4和log6<br><img title="setState_01" src="http://oiwdpm2o1.bkt.clouddn.com/static/images/react/setState_03.jpg?imageView2/1/w/770/h/500"></p>
<p>现在看来<code>setState</code>似乎和在哪里调用没有关系，而是和调用方式有关系。那么为什么log1~4的结果显示的就像<code>setState</code>是一个异步函数呢？</p>
<h2><span id="从函数调用栈入手">从函数调用栈入手</span></h2><p>以下仅对比同步setState(log1、2)和异步setState(log5、6)的结果。</p>
<h3><span id="log1-2的call-stack">log1、2的call stack</span></h3><p>在<code>render</code>函数中打上断点调试。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Count: &#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;this.clickHandler&#125;&gt;Count Add&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>查看调用栈：<br><img title="setState_01" src="http://oiwdpm2o1.bkt.clouddn.com/static/images/react/callStack_01.jpg?imageView2/1/w/770/h/500"><br>不要被这么冗长的调用栈吓倒(微笑脸),注意观察图书箭头所指向的2个函数<code>batcheUpdates</code>，字面意思就是批量更新，我吗暂且先放一边，看看log 5、6的调用栈是怎样的:</p>
<h3><span id="log5-6的call-stack">log5、6的call stack</span></h3><p>老样子，打上断点：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Count: &#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查看调用栈：<br><img title="setState_01" src="http://oiwdpm2o1.bkt.clouddn.com/static/images/react/callStack_02.jpg?imageView2/1/w/770/h/500"><br>可以看到这里也有<code>enqueueUpdate</code>方法，那么这个<code>enqueueUpdate</code>究竟是何方神圣呢？<br>不急，要想知道答案的话就得去看看React的源码了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReactComponent.prototype.setState = <span class="function"><span class="keyword">function</span> (<span class="params">partialState, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState);</span><br><span class="line">  <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.updater.enqueueCallback(<span class="keyword">this</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实我们所定义的组件都是继承自<code>ReactComponent</code>这个父类，通过<code>this.updater.enqueueSetState(this, partialState)</code>的方式去设置state。那么<code>this.updater</code>又是何方神圣呢？<br>通过查看<code>ReactCompositeComponent.js</code>源码发现了以下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReactCompositeComponent.mount</span></span><br><span class="line"><span class="keyword">var</span> updateQueue = transaction.getUpdateQueue();<span class="comment">// 得到更新队列</span></span><br><span class="line"><span class="comment">// 略</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Component(publicProps, publicContext, updateQueue);</span><br></pre></td></tr></table></figure></p>
<p>上面的<code>Component</code>就是我们自定义组件的构造类函数，在实例化自定义组件的时候传入。我们再来看看React自定义组件的够着函数代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//React.createClass</span></span><br><span class="line"><span class="keyword">var</span> Constructor = identity(<span class="function"><span class="keyword">function</span>(<span class="params">props, context, updater</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">    <span class="keyword">this</span>.context = context;</span><br><span class="line">    <span class="keyword">this</span>.refs = emptyObject;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue; <span class="comment">// &lt;== 这里赋值给了组件实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = <span class="literal">null</span>;    </span><br><span class="line">    <span class="keyword">var</span> initialState = <span class="keyword">this</span>.getInitialState ? <span class="keyword">this</span>.getInitialState() : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.state = initialState;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<p>一切真想大白了，现在我们知道了<code>this.updater</code>其实就是<code>transaction.getUpdateQueue()</code>返回的一个对象，我们接着查找相关源码，发现了<code>this.updater.enqueueSetState</code>的源码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReactUpdateQueue.js</span></span><br><span class="line">enqueueSetState: <span class="function"><span class="keyword">function</span>(<span class="params">publicInstance, partialState</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="keyword">if</span> (!internalInstance) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> queue =</span><br><span class="line">      internalInstance._pendingStateQueue ||</span><br><span class="line">      (internalInstance._pendingStateQueue = []);</span><br><span class="line">    queue.push(partialState); <span class="comment">// 这里将设置的state push到internalInstance._pendingStateQueue上</span></span><br><span class="line"></span><br><span class="line">    enqueueUpdate(internalInstance); <span class="comment">// 调用队列更新</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码你一定有很多疑惑，不要着急，这里的<code>internalInstance</code>其实就是<code>ReactCompositeComponent</code>的一个实例，它负责管理我们的自定义组件的渲染、更新和销毁。在此我们仅需要看最后一层调用就可以了，还记得我们上面函数调用栈的2个<code>enqueueUpdate</code>吗，这个就是第一个<code>enqueueUpdate</code>，他就是一个简单的函数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">internalInstance</span>) </span>&#123; <span class="comment">// ReactCompositeComponent 的实例</span></span><br><span class="line">  ReactUpdates.enqueueUpdate(internalInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数调用的是<code>ReactUpdates.enqueueUpdate</code>方法，这就是第二个<code>enqueueUpdate</code>。你可能已经有点晕了，但是没关系坚持去理解，多尝试几次就好了(微笑脸)<br>通过查看<code>enqueueUpdate</code>的源码发现就是一个对象，负责的是React有关的更新、设置回调等。我们看看<code>ReactUpdates.enqueueUpdate</code>代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">  ensureInjected(); <span class="comment">// ==&gt; 这个就是React 建成 transaction是否成功注入的一个函数，没有实际逻辑功能只是用来在console中提示，暂时不用管</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123; <span class="comment">// batchingStrategy.isBatchingUpdates就是一个布尔值</span></span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dirtyComponents.push(component);<span class="comment">// 看名字就知道 脏组件列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：上面的代码是React调用<code>setState</code>后是否是异步执行的真正原因！！！<br>这里的逻辑其实很难将清楚，但是你可以简单理解为就是判断<code>batchingStrategy.isBatchingUpdates</code>是否为false，为false就立即调用<code>batchingStrategy.batchedUpdates</code>执行更新，否则就将当前的脏组件放入<code>dirtyComponents</code>中，等待<code>batchingStrategy.isBatchingUpdates</code>置为<code>false</code>之后批量更新。其实<code>batchingStrategy</code>就是一个React策略类对象，它很简单，简单到只有2个属性：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">  isBatchingUpdates: <span class="literal">false</span>, <span class="comment">// 布尔值标识</span></span><br><span class="line"></span><br><span class="line">  batchedUpdates: <span class="function"><span class="keyword">function</span> (<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</span><br><span class="line"></span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span>; <span class="comment">// 标识置为true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The code is written this way to avoid extra allocations</span></span><br><span class="line">    <span class="keyword">if</span> (alreadyBatchingUpdates) &#123;</span><br><span class="line">      callback(a, b, c, d, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>ReactDefaultBatchingStrategy</code>是React的一个批量更新策略对象，只要当前在React的批量更新当作，<code>ReactDefaultBatchingStrategy.isBatchingUpdates</code>就为<code>true</code>，此时同步调用<code>setState</code>由于<code>isBatchingUpdates</code>为<code>true</code>，只能放到<code>dirtyComponents</code>当中，等待当前批量更新完毕后从<code>dirtyComponents</code>中一个个拿出dirtyComponent执行更新。而当异步方式调用<code>setState</code>的时候，此时React批量更新完毕，<code>isBatchingUpdates</code>为<code>false</code>，通过执行<code>batchingStrategy.batchedUpdates</code>立即更新当前<code>state</code>。讲到这里已经可以解释上述几处log的区别了：</p>
<ul>
<li>log1、2和log3、4是一类的，因为他们是同步调用<code>setState</code>，此时React正处于批量更新当作，所以2次setState只为讲当前<code>component</code> push到<code>dirtyComponents</code>中，所以<code>console</code>到的<code>count</code>还是0，并且最后2次state做了pending处理后<code>count</code>变为1；</li>
<li><p>log5、6由于在<code>setTimeout</code>中调用，此时React已经批量更新完毕，<code>isBatchingUpdates</code>为<code>false</code>，直接执行更新，state立即加1，这也就解释了5、6处<code>setState</code>就好像是同步更新state一样。<br>注意：上面的<code>transaction.perform</code>是关于React的事务，在React中调用了大量的事务来保证批量渲染、更新和卸载的正确执行。这里关于<code>transaction</code>后续我会单独讲解，感兴趣的童鞋也可以自行查看相关源码。</p>
<h2><span id="总结">总结</span></h2></li>
<li><p>React中自定义组件统一都继承自<code>ReactComponent</code>，在<code>ReactComponent</code>上定义了<code>setState</code>方法。</p>
</li>
<li>React通过<code>updater</code>来执行更新，这个updater是在生成组件实例中传入到构造函数当中的。</li>
<li><code>updater</code>其实就是<code>ReactUpdates</code>，定义的<code>enqueueSetState</code>方法通过层层调用，执行更新。</li>
<li>React通过一个<code>ReactDefaultBatchingStrategy</code>对象管理更新，这个对象有一个 <code>isBatchingUpdates</code>属性，标识当前是否正在更新，如果当前正在更新则将待更新的组件<code>push</code>到<code>dirtyComponents</code>，等待React批量更新完成后统一更新，否则执行<code>batchingStrategy.batchedUpdates</code>立即更新当前<code>state</code>。</li>
</ul>
<h3><span id="最后">最后</span></h3><p>关于React是如何进入批量更新，和如何退出批量更新的问题稍后我们讲到，需要结合到<code>transaction</code>统一来讲。最后，精力有限，难民有疏漏和错误，欢迎各位指正。(^=^)</p>
<p>附上demo地址==&gt;  <a href="http://codepen.io/Simmer/pen/xqdaVz" target="_blank" rel="noopener">&gt;&gt;&gt;我是地址</a></p>
</div></article></div><div class="paginator clearfix"><a href="/2017/04/23/photography/helloPhotography/" class="prev">上一篇</a><a href="/2017/02/08/backend/nodejs-fs/" class="next">下一篇</a></div></section><section class="footer"><div class="copyright">© 2015-2017 <a href="/about/index.html">Simmer</a> | Front-ender | Amateur photographer. </div><div id="go-pg-top" style="display: none; opacity: 0.6;" title="返回顶部">TOP</div></section></div></div><script src="/js/jquery-1.11.1.js"></script><script src="/js/common.js"></script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1257488449' class='cnzz'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1257488449%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></body></html>