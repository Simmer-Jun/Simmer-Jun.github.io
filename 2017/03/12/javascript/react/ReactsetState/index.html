<!DOCTYPE html><html class="no-js"><head><meta charset="utf-8"><title>司马-Simmer-React全家桶－揭秘setState(二)</title><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.icon"><link rel="stylesheet" href="/css/style.css"><!-- detech broser's env --><script src="/js/modernizr.js" type="text/javascript"></script><meta name="description" content="A Blog Powered By Hexo"></head><body><div class="nav clearfix nav-show"><div title="隐藏导航" id="nav-btn" class="nav-guide"><i class="icon nav-icon">&#xe603;</i></div><div class="nav-inner  clearfix"><a href="/" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe606;</div><span>Home</span></div></a><a href="/archives" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe602;</div><span>Archives</span></div></a><a href="/photography" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe604;</div><span>摄影</span></div></a><a href="/tags" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe601;</div><span>Tags</span></div></a><a href="/about" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe605;</div><span>About</span></div></a></div></div><div class="wraper"><div class="main"><section class="content"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2017/03/12/javascript/react/ReactsetState/" class="post-title-link">React全家桶－揭秘setState(二)</a></h2><div class="post-subtitle clearfix"><span class="post-date">2017年3月12日</span><div class="post-tag"><a href="/2017/03/12/javascript/react/ReactsetState/"><sapn>React</sapn><i class="icon">&#xe600;</i></a></div></div><div class="post-content"><p>谈到React，不得不提到的就是<code>state</code>，相信你一定用过很多次的<code>setState</code>，也知道<code>setState</code>是一个异步方法，正如官网说的：</p>
<blockquote>
<p>setState() does not immediately mutate this.state but creates a pending state transition. Accessing this.state after calling this method can potentially return the existing value.<br>There is no guarantee of synchronous operation of calls to setState and calls may be batched for performance gains.</p>
</blockquote>
<a id="more"></a>
<h2 id="setstate-diao-yong-wei-zhi"><a href="#setState调用位置" class="headerlink" title="setState调用位置"></a>setState调用位置<a href="setstate-diao-yong-wei-zhi" class="header-anchor">"#"</a></h2><p>从React调用stateState的位置来看情况无非有2种:</p>
<ul>
<li>一种是在生命周期函数中 <code>componentWillMount</code>、<code>componentDidMount</code>、<code>componentWillReceiveProps</code>、<code>render</code>等</li>
<li>在各种handler中(包括组件本身元素的handler和通过this.props.handerXXX)</li>
</ul>
<h3 id="zai-handler-zhong-setstate"><a href="#在handler中setState" class="headerlink" title="在handler中setState"></a>在handler中setState<a href="zai-handler-zhong-setstate" class="header-anchor">"#"</a></h3><p>思考以下代码运行结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props)&#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      count: <span class="number">0</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.clickHandler = <span class="keyword">this</span>.clickHandler.bind(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">  clickHandler()&#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;</div><div class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span></div><div class="line">    &#125;)</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"log 1 :"</span>, <span class="keyword">this</span>.state.count); <span class="comment">// log 1</span></div><div class="line">    <span class="keyword">this</span>.setState(&#123;</div><div class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span></div><div class="line">    &#125;)</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"log 2 :"</span>, <span class="keyword">this</span>.state.count); <span class="comment">// log 2</span></div><div class="line">  &#125;</div><div class="line">  render()&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.clickHandler&#125;</span>&gt;</span>Count Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>试着想一下当点击button的时候2次log的结果分别是什么？先不急着公布答案，在来看看下面的代码</p>
<h3 id="zai-sheng-ming-zhou-qi-zhong-setstate"><a href="#在生命周期中setState" class="headerlink" title="在生命周期中setState"></a>在生命周期中setState<a href="zai-sheng-ming-zhou-qi-zhong-setstate" class="header-anchor">"#"</a></h3><p>再次思考以下代码运行结果<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props)&#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      count: <span class="number">0</span></div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  componentWillMount()&#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;</div><div class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span></div><div class="line">    &#125;)</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"log 3 :"</span>, <span class="keyword">this</span>.state.count); <span class="comment">// log 3</span></div><div class="line">    <span class="keyword">this</span>.setState(&#123;</div><div class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span></div><div class="line">    &#125;)</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"log 4 :"</span>, <span class="keyword">this</span>.state.count); <span class="comment">// log 4</span></div><div class="line">  &#125;</div><div class="line">  render()&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你一定知道在<code>componentWillMount</code>调用<code>setState</code>是会合并state而不会触发re-render，那么log3和log4分别输出多少呢？</p>
<h2 id="setstate-diao-yong-fang-shi"><a href="#setState调用方式" class="headerlink" title="setState调用方式"></a>setState调用方式<a href="setstate-diao-yong-fang-shi" class="header-anchor">"#"</a></h2><p>众所周知，在JavaScript中充满了各种异步函数，当然<code>setState</code>也可以被异步调用，再来思考下面的代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props)&#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      count: <span class="number">0</span></div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  componentWillMount()&#123;</div><div class="line">    setTimeout(()=&gt; &#123;</div><div class="line">      <span class="keyword">this</span>.setState(&#123;</div><div class="line">        count: <span class="keyword">this</span>.state.count + <span class="number">1</span></div><div class="line">      &#125;)</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"log 5 :"</span>, <span class="keyword">this</span>.state.count); <span class="comment">// log 5</span></div><div class="line">      <span class="keyword">this</span>.setState(&#123;</div><div class="line">        count: <span class="keyword">this</span>.state.count + <span class="number">1</span></div><div class="line">      &#125;)</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"log 6 :"</span>, <span class="keyword">this</span>.state.count); <span class="comment">// log 6</span></div><div class="line">    &#125;</div><div class="line">    &#125;, <span class="number">0</span>)</div><div class="line">  &#125;</div><div class="line">  render()&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的<code>setState</code>是被放入异步执行队列被执行的，那么log5和log6分别输出多少呢？(在各种handler回调中执行的异步setState类似这里的5和6)</p>
<h2 id="da-an"><a href="#答案" class="headerlink" title="答案"></a>答案<a href="da-an" class="header-anchor">"#"</a></h2><p>log1和log2<br><img title="setState_01" src="http://oiwdpm2o1.bkt.clouddn.com/static/images/react/setState_01.jpg?imageView2/2/w/600"><br>log3和log4<br><img title="setState_01" src="http://oiwdpm2o1.bkt.clouddn.com/static/images/react/setState_02.jpg?imageView2/2/w/600"><br>log4和log6<br><img title="setState_01" src="http://oiwdpm2o1.bkt.clouddn.com/static/images/react/setState_03.jpg?imageView2/2/w/600"></p>
<p>现在看来<code>setState</code>似乎和在哪里调用没有关系，而是和调用方式有关系。那么为什么log1~4的结果显示的就像<code>setState</code>是一个异步函数呢？</p>
<h2 id="cong-han-shu-diao-yong-zhan-ru-shou"><a href="#从函数调用栈入手" class="headerlink" title="从函数调用栈入手"></a>从函数调用栈入手<a href="cong-han-shu-diao-yong-zhan-ru-shou" class="header-anchor">"#"</a></h2><p>以下仅对比同步setState(log1、2)和异步setState(log5、6)的结果。</p>
<h3 id="log1-2-de-call-stack"><a href="#log1、2的call-stack" class="headerlink" title="log1、2的call stack"></a>log1、2的call stack<a href="log1-2-de-call-stack" class="header-anchor">"#"</a></h3><p>在<code>render</code>函数中打上断点调试。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">render()&#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.clickHandler&#125;</span>&gt;</span>Count Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查看调用栈：<br><img title="setState_01" src="http://oiwdpm2o1.bkt.clouddn.com/static/images/react/callStack_01.jpg?imageView2/2/w/600"><br>不要被这么冗长的调用栈吓倒(微笑脸),注意观察图书箭头所指向的2个函数<code>batcheUpdates</code>，字面意思就是批量更新，我吗暂且先放一边，看看log 5、6的调用栈是怎样的:</p>
<h3 id="log5-6-de-call-stack"><a href="#log5、6的call-stack" class="headerlink" title="log5、6的call stack"></a>log5、6的call stack<a href="log5-6-de-call-stack" class="header-anchor">"#"</a></h3><p>老样子，打上断点：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">render()&#123;</div><div class="line">  <span class="keyword">debugger</span>;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查看调用栈：<br><img title="setState_01" src="http://oiwdpm2o1.bkt.clouddn.com/static/images/react/callStack_02.jpg?imageView2/2/w/600"><br>可以看到这里也有<code>enqueueUpdate</code>方法，那么这个<code>enqueueUpdate</code>究竟是何方神圣呢？<br>不急，要想知道答案的话就得去看看React的源码了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ReactComponent.prototype.setState = <span class="function"><span class="keyword">function</span> (<span class="params">partialState, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState);</div><div class="line">  <span class="keyword">if</span> (callback) &#123;</div><div class="line">    <span class="keyword">this</span>.updater.enqueueCallback(<span class="keyword">this</span>, callback);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其实我们所定义的组件都是继承自<code>ReactComponent</code>这个父类，通过<code>this.updater.enqueueSetState(this, partialState)</code>的方式去设置state。那么<code>this.updater</code>又是何方神圣呢？<br>通过查看<code>ReactCompositeComponent.js</code>源码发现了以下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ReactCompositeComponent.mount</span></div><div class="line"><span class="keyword">var</span> updateQueue = transaction.getUpdateQueue();<span class="comment">// 得到更新队列</span></div><div class="line"><span class="comment">// 略</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> Component(publicProps, publicContext, updateQueue);</div></pre></td></tr></table></figure></p>
<p>上面的<code>Component</code>就是我们自定义组件的构造类函数，在实例化自定义组件的时候传入。我们再来看看React自定义组件的够着函数代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//React.createClass</span></div><div class="line"><span class="keyword">var</span> Constructor = identity(<span class="function"><span class="keyword">function</span>(<span class="params">props, context, updater</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.props = props;</div><div class="line">    <span class="keyword">this</span>.context = context;</div><div class="line">    <span class="keyword">this</span>.refs = emptyObject;</div><div class="line">    </div><div class="line">    <span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue; <span class="comment">// &lt;== 这里赋值给了组件实例</span></div><div class="line"></div><div class="line">    <span class="keyword">this</span>.state = <span class="literal">null</span>;    </div><div class="line">    <span class="keyword">var</span> initialState = <span class="keyword">this</span>.getInitialState ? <span class="keyword">this</span>.getInitialState() : <span class="literal">null</span>;</div><div class="line">    <span class="keyword">this</span>.state = initialState;</div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>
<p>一切真想大白了，现在我们知道了<code>this.updater</code>其实就是<code>transaction.getUpdateQueue()</code>返回的一个对象，我们接着查找相关源码，发现了<code>this.updater.enqueueSetState</code>的源码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ReactUpdateQueue.js</span></div><div class="line">enqueueSetState: <span class="function"><span class="keyword">function</span>(<span class="params">publicInstance, partialState</span>) </span>&#123;</div><div class="line">    <span class="comment">//略</span></div><div class="line">    <span class="keyword">if</span> (!internalInstance) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> queue =</div><div class="line">      internalInstance._pendingStateQueue ||</div><div class="line">      (internalInstance._pendingStateQueue = []);</div><div class="line">    queue.push(partialState); <span class="comment">// 这里将设置的state push到internalInstance._pendingStateQueue上</span></div><div class="line"></div><div class="line">    enqueueUpdate(internalInstance); <span class="comment">// 调用队列更新</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码你一定有很多疑惑，不要着急，这里的<code>internalInstance</code>其实就是<code>ReactCompositeComponent</code>的一个实例，它负责管理我们的自定义组件的渲染、更新和销毁。在此我们仅需要看最后一层调用就可以了，还记得我们上面函数调用栈的2个<code>enqueueUpdate</code>吗，这个就是第一个<code>enqueueUpdate</code>，他就是一个简单的函数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">internalInstance</span>) </span>&#123; <span class="comment">// ReactCompositeComponent 的实例</span></div><div class="line">  ReactUpdates.enqueueUpdate(internalInstance);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数调用的是<code>ReactUpdates.enqueueUpdate</code>方法，这就是第二个<code>enqueueUpdate</code>。你可能已经有点晕了，但是没关系坚持去理解，多尝试几次就好了(微笑脸)<br>通过查看<code>enqueueUpdate</code>的源码发现就是一个对象，负责的是React有关的更新、设置回调等。我们看看<code>ReactUpdates.enqueueUpdate</code>代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">component</span>) </span>&#123;</div><div class="line">  ensureInjected(); <span class="comment">// ==&gt; 这个就是React 建成 transaction是否成功注入的一个函数，没有实际逻辑功能只是用来在console中提示，暂时不用管</span></div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123; <span class="comment">// batchingStrategy.isBatchingUpdates就是一个布尔值</span></div><div class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  dirtyComponents.push(component);<span class="comment">// 看名字就知道 脏组件列表</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：上面的代码是React调用<code>setState</code>后是否是异步执行的真正原因！！！<br>这里的逻辑其实很难将清楚，但是你可以简单理解为就是判断<code>batchingStrategy.isBatchingUpdates</code>是否为false，为false就立即调用<code>batchingStrategy.batchedUpdates</code>执行更新，否则就将当前的脏组件放入<code>dirtyComponents</code>中，等待<code>batchingStrategy.isBatchingUpdates</code>置为<code>false</code>之后批量更新。其实<code>batchingStrategy</code>就是一个React策略类对象，它很简单，简单到只有2个属性：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = &#123;</div><div class="line">  isBatchingUpdates: <span class="literal">false</span>, <span class="comment">// 布尔值标识</span></div><div class="line"></div><div class="line">  batchedUpdates: <span class="function"><span class="keyword">function</span> (<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</div><div class="line"></div><div class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span>; <span class="comment">// 标识置为true</span></div><div class="line"></div><div class="line">    <span class="comment">// The code is written this way to avoid extra allocations</span></div><div class="line">    <span class="keyword">if</span> (alreadyBatchingUpdates) &#123;</div><div class="line">      callback(a, b, c, d, e);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>ReactDefaultBatchingStrategy</code>是React的一个批量更新策略对象，只要当前在React的批量更新当作，<code>ReactDefaultBatchingStrategy.isBatchingUpdates</code>就为<code>true</code>，此时同步调用<code>setState</code>由于<code>isBatchingUpdates</code>为<code>true</code>，只能放到<code>dirtyComponents</code>当中，等待当前批量更新完毕后从<code>dirtyComponents</code>中一个个拿出dirtyComponent执行更新。而当异步方式调用<code>setState</code>的时候，此时React批量更新完毕，<code>isBatchingUpdates</code>为<code>false</code>，通过执行<code>batchingStrategy.batchedUpdates</code>立即更新当前<code>state</code>。讲到这里已经可以解释上述几处log的区别了：</p>
<ul>
<li>log1、2和log3、4是一类的，因为他们是同步调用<code>setState</code>，此时React正处于批量更新当作，所以2次setState只为讲当前<code>component</code> push到<code>dirtyComponents</code>中，所以<code>console</code>到的<code>count</code>还是0，并且最后2次state做了pending处理后<code>count</code>变为1；</li>
<li><p>log5、6由于在<code>setTimeout</code>中调用，此时React已经批量更新完毕，<code>isBatchingUpdates</code>为<code>false</code>，直接执行更新，state立即加1，这也就解释了5、6处<code>setState</code>就好像是同步更新state一样。<br>注意：上面的<code>transaction.perform</code>是关于React的事务，在React中调用了大量的事务来保证批量渲染、更新和卸载的正确执行。这里关于<code>transaction</code>后续我会单独讲解，感兴趣的童鞋也可以自行查看相关源码。</p>
<h2 id="zong-jie"><a href="#总结" class="headerlink" title="总结"></a>总结<a href="zong-jie" class="header-anchor">"#"</a></h2></li>
<li><p>React中自定义组件统一都继承自<code>ReactComponent</code>，在<code>ReactComponent</code>上定义了<code>setState</code>方法。</p>
</li>
<li>React通过<code>updater</code>来执行更新，这个updater是在生成组件实例中传入到构造函数当中的。</li>
<li><code>updater</code>其实就是<code>ReactUpdates</code>，定义的<code>enqueueSetState</code>方法通过层层调用，执行更新。</li>
<li>React通过一个<code>ReactDefaultBatchingStrategy</code>对象管理更新，这个对象有一个 <code>isBatchingUpdates</code>属性，标识当前是否正在更新，如果当前正在更新则将待更新的组件<code>push</code>到<code>dirtyComponents</code>，等待React批量更新完成后统一更新，否则执行<code>batchingStrategy.batchedUpdates</code>立即更新当前<code>state</code>。</li>
</ul>
<h3 id="zui-hou"><a href="#最后" class="headerlink" title="最后"></a>最后<a href="zui-hou" class="header-anchor">"#"</a></h3><p>关于React是如何进入批量更新，和如何退出批量更新的问题稍后我们讲到，需要结合到<code>transaction</code>统一来讲。最后，精力有限，难民有疏漏和错误，欢迎各位指正。(^=^)</p>
<p>附上demo地址==&gt;  <a href="http://codepen.io/Simmer/pen/xqdaVz" target="_blank" rel="external">&gt;&gt;&gt;我是地址</a></p>
</div></article></div><div class="paginator clearfix"><a href="/2017/04/23/photography/helloPhotography/" class="prev">上一篇</a><a href="/2017/02/08/nodejs-fs/" class="next">下一篇</a></div></section><section class="footer"><div>Host By Github Pages | Thans For Coming | Hexo Theme <a href="https://github.com/Simmer-Jun/hexo-theme-grace">Grace</a></div><div class="copyright">© 2017 <a href="/about/index.html">Simmer</a>. All rights reserved.</div><div id="go-pg-top" style="display: none; opacity: 0.6;" title="返回顶部">TOP</div></section></div></div><script src="/js/jquery-1.11.1.js"></script><script src="/js/common.js"></script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1257488449' class='cnzz'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1257488449%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></body></html>