<!DOCTYPE html><html class="no-js"><head><meta charset="utf-8"><title>司马-Simmer-React GUIDES</title><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.icon"><link rel="stylesheet" href="/css/style.css"><!-- detech broser's env --><script src="/js/modernizr.js" type="text/javascript"></script><meta name="description" content="A Blog Powered By Hexo"></head><body><div class="nav clearfix"><div title="隐藏导航" id="nav-btn" class="nav-guide"><i class="icon nav-icon">&#xe603;</i></div><div class="nav-inner  clearfix "><a href="/" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe606;</div><span>Home</span></div></a><a href="/archives" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe602;</div><span>Archives</span></div></a><a href="/photography" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe604;</div><span>摄影</span></div></a><a href="/tags" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe601;</div><span>Tags</span></div></a><a href="/about" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe605;</div><span>About</span></div></a></div></div><div class="wraper"><div class="main"><section class="content"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2016/10/12/javascript/start-React/" class="post-title-link">React GUIDES</a></h2><div class="post-subtitle clearfix"><span class="post-date">2016年10月12日</span><div class="post-tag"><a href="/2016/10/12/javascript/start-React/"><sapn>React</sapn><i class="icon">&#xe600;</i></a></div></div><div class="post-content"><p>写在前面：好久没写React，相关的基础知识都快忘的差不多了，乘着今天不忙，将官方的英文指南过一遍（注意：不是翻译!）</p>
<a id="more"></a>
<h1><span id="why-react">Why React</span></h1><p>React的构建是用来解决一个问题： 构建数据实时更新的大型应用</p>
<h1><span id="介绍jsx">介绍JSX</span></h1><p>考虑一下下面的变量表达式：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, simmer!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这个有趣的标签语法既不是字符串也不是HTML，实际上它叫做JSX，是一个JavaScript的语法扩展。看起来JSX是一个模版语言，但是它支持全面的JavaScript语法。</p>
<h3><span id="jsx中的嵌套表达式">JSX中的嵌套表达式</span></h3><p>你可以在JSX中通过大括号嵌套任何JavaScript语法。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatName</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> user.firstName + <span class="string">' '</span> + user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">'Harper'</span>,</span><br><span class="line">  lastName: <span class="string">'Perez'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    Hello, &#123;formatName(user)&#125;!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  element,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p>
<p>我们通过括号包裹JSX，并且为了可读性将它拆分成多行，这也有助于避免分号的自动插入。</p>
<h3><span id="jsx也是一个表达式">JSX也是一个表达式</span></h3><p>在编译以后，JSX表达式将会变成常规的JavaScript对象。</p>
<h3><span id="在jsx中指定属性">在JSX中指定属性</span></h3><ul>
<li>可以通过引号来表达一个存文本的属性值</li>
<li>也可以使用大括号来嵌套JavaScript表达式作为属性值</li>
</ul>
<h3><span id="在jsx中指定子元素">在JSX中指定子元素</span></h3><ul>
<li>空标签可以使用<code>/&gt;</code>闭合标签</li>
<li>JSX标签也可以包含子元素</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;Hello!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &lt;h2&gt;Good to see you here.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>警告<br>由于JSX比HTML更接近JavaScript， React DOM 使用驼峰属性命名规则而不是HTML的属性名，例如 在JSX中<code>class</code>变成了<code>className</code>，<code>tabindex</code>变成了<code>tabIndex</code>.</p>
</blockquote>
<h3><span id="jsx-防止注入攻击">JSX 防止注入攻击</span></h3><p>默认情况下，在渲染前React DOM会阻止在JSX中嵌入任何值。</p>
<h1><span id="渲染元素">渲染元素</span></h1><p>元素是构建React应用的最小化模块。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">hello</span> , <span class="attr">simmer</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>不同于浏览器的DOM元素，React元素是纯对象并且创建所花费的代价很小。 React DOM则更关心根据React元素来更新DOM。</p>
<blockquote>
<p>提示<br>一个可能会使得元素变得疑惑的点是被更加广泛熟知的‘组件’概念。我们将会在下一届介绍组件。组件是通过元素来构成的，并且我们鼓励你在跳到后面内容前先阅读本节内容。</p>
</blockquote>
<h3><span id="渲染一个元素到dom中">渲染一个元素到DOM中</span></h3><p>为了渲染一个React元素到DOM根节点，将他们同时传入<code>ReactDOM.render()</code>中。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3><span id="更新渲染元素">更新渲染元素</span></h3><p>React元素是不可变的，一旦你创建了一个元素后就无法改变它的子元素或者属性。这就像是电影里的一帧，代表的是在某一时刻的UI。<br>目前我们熟知的更新UI的方法是创建一个新的元素并且把它传到<code>ReactDOM.render()</code>中。</p>
<h1><span id="组件和属性">组件和属性</span></h1><p>组件让你将UI拆分为独立的，可复用的，可已独立思考的模块。<br>从概念上讲，组件就像是JavaScript函数。他们接受任意的输入（叫做’Props’）并且返回能描述当前UI表现的React元素。</p>
<h3><span id="functional-and-class-components">Functional and Class Components</span></h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="渲染一个组件">渲染一个组件</span></h4><p>在前面我们遇到的React元素仅仅代表DOM标签<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span>/&gt;</span></span><span class="string">''</span></span><br></pre></td></tr></table></figure></p>
<p>然而，元素也可以代表用户定义的组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sunny"</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>当React发现某一个原属代表的是一个用户定义好的组件，并且将JSX的属性作为一个对象传递到组件中。我们叫这个对象为”props”。</p>
<p>下面是一个栗子，它渲染”Hello, Sunny”到页面中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sunny"</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">ReactDOM.render(</span></span><br><span class="line"><span class="xml">  element,</span></span><br><span class="line"><span class="xml">  document.getElementById('root')</span></span><br><span class="line"><span class="xml">);</span></span><br></pre></td></tr></table></figure></p>
<p>让我们来简要概括一下在这个栗子中发生了什么：</p>
<ul>
<li>我们调用<code>ReactDOM.render()</code>并且传递<code>&lt;Welcome name=&quot;Sunny&quot; /&gt;</code>这个元素到其中。</li>
<li>React 调用<code>Welcome</code>组件并且将<code>{name: &quot;Sunny&quot;}</code>作为<code>props</code>传递到组件中。</li>
<li>组件<code>Welcome</code>返回<code>&lt;h1&gt;hello, Sunny&lt;/h1&gt;</code>元素作为结果。</li>
<li>ReactDOM 有效率的更新DOM来匹配<code>&lt;h1&gt;hello, Sunny&lt;/h1&gt;</code>。</li>
</ul>
<h3><span id="编写组件-ampamp-解构组件">编写组件 &amp;&amp; 解构组件</span></h3><ul>
<li>组件嵌套</li>
<li>将组件进行拆分，可以有效的复用组件<h3><span id="props是只读的">Props是只读的</span></h3>看一个简单的函数：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">functon addResult(a. b) &#123;</span><br><span class="line">	<span class="keyword">return</span> a +b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的函数被叫做是纯函数因为他们不会试图去改变输入，并且同样的输入总会有同样的输出。</p>
<blockquote>
<p>为了反映他们的props，所有的React组件必须按表现的像一个纯函数一样。</p>
</blockquote>
<h1><span id="状态和生命周期">状态和生命周期</span></h1><p>略<br>tips: 如果你没有在<code>render</code>方法中没有使用一些数据，那么它们就不该出现在<code>state</code>中</p>
<h2><span id="正确的使用state">正确的使用State</span></h2><h3><span id="不要直接修改state">不要直接修改State</span></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state.comment = <span class="string">"hello"</span>; <span class="comment">// wrong</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">上面的方法将不会触发React的重新渲染，所以应该使用以下方法：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">comment</span>: <span class="string">"hello"</span>&#125;);</span><br></pre></td></tr></table></figure>
<h3><span id="状态的更新可能是异步的">状态的更新可能是异步的</span></h3><p>为了性能方面的考虑，React可能会将批量的<code>setState()</code>方法合并为一次简单的更新。<br>也正是由于<code>this.props</code>和<code>this.state</code>可能是异步更新的，你不能根据它们的值来计算下一次的状态。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>为了修复这个问题，我们可以用第二种方法来调用<code>setState()</code>,那就是传递一个函数而不是一个对象进去。这个函数将会接受前一时刻的state最为第一个参数，更新被应用时的props作为第二个参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">	counter: prevState.counter + props.increment    <span class="comment">// Correct</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></p>
<h3><span id="state的更新是一次合并">State的更新是一次合并</span></h3><p>当你调用<code>setState()</code>方法的时候，React将会合并你提供的对象到当前的state中。<br>注意： state的合并是浅合并。</p>
<h1><span id="处理事件">处理事件</span></h1><p>首先注意在JSX中的事件和处理DOM的事件有些不同。</p>
<ul>
<li>React事件的取名是驼峰式的，不是小写方式的。</li>
<li>在JSX中传递一个函数作为事件处理函数，而不是字符串。</li>
<li>在React中不能通过返回false来阻止浏览器的默认行为，而是需要使用<code>preventDetault</code></li>
</ul>
<p>使用ES2015 class语法定义组件，一般的建议是在constructor中绑定好事件处理的handler/或者使用箭头函数</p>
<h3><span id="有条件的渲染">有条件的渲染</span></h3><p>略</p>
<h3><span id="列表和key">列表和key</span></h3><p>略</p>
<h3><span id="表单">表单</span></h3><p>区分受控表单和非受控表单的区别</p>
<h1><span id="提取公共状态">提取公共状态</span></h1><p>通常，如果组件需要重新渲染，我们首先会想到添加一个state到组件中。接着，当其他的组件也需要这个状态的时候，最好的做法是将状态提升到它们（组件）最近的共同祖先，而不是是这在不同的组件之间尝试同步状态，换句话说，你需要依靠这种自上而下的数据流。</p>
<h1><span id="组成-vs-继承">组成 Vs 继承</span></h1><p>未完待续</p>
</div></article></div><div class="paginator clearfix"><a href="/2016/12/29/summary-about-2016/" class="prev">上一篇</a><a href="/2016/04/16/21Days/" class="next">下一篇</a></div></section><section class="footer"><div class="copyright">©2015-2019 <a href="/about/index.html">Simmer</a> | Front-ender | Amateur photographer. </div><div id="go-pg-top" style="display: none; opacity: 0.6;" title="返回顶部">TOP</div></section></div></div><script src="/js/jquery-1.11.1.js"></script><script src="/js/common.js"></script></script></body></html>