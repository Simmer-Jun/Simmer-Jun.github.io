<!DOCTYPE html><html class="no-js"><head><meta charset="utf-8"><title>司马-Simmer-React GUIDES</title><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.icon"><link rel="stylesheet" href="/css/style.css"><!-- detech broser's env --><script src="/js/modernizr.js" type="text/javascript"></script><meta name="description" content="A Blog Powered By Hexo"></head><body><div class="nav clearfix nav-show"><div title="隐藏导航" id="nav-btn" class="nav-guide"><i class="icon nav-icon">&#xe603;</i></div><div class="nav-inner  clearfix"><a href="/" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe606;</div><span>Home</span></div></a><a href="/archives" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe602;</div><span>Archives</span></div></a><a href="/photography" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe604;</div><span>摄影</span></div></a><a href="/tags" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe601;</div><span>Tags</span></div></a><a href="/about" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe605;</div><span>About</span></div></a></div></div><div class="wraper"><div class="main"><section class="content"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2016/10/12/javascript/react/start-React/" class="post-title-link">React GUIDES</a></h2><div class="post-subtitle clearfix"><span class="post-date">2016年10月12日</span><div class="post-tag"><a href="/2016/10/12/javascript/react/start-React/"><sapn>React</sapn><i class="icon">&#xe600;</i></a></div></div><div class="post-content"><p>写在前面：好久没写React，相关的基础知识都快忘的差不多了，乘着今天不忙，将官方的英文指南过一遍（注意：不是翻译!）</p>
<a id="more"></a>
<h1 id="why-react"><a href="#Why-React" class="headerlink" title="Why React"></a>Why React<a href="why-react" class="header-anchor">"#"</a></h1><p>React的构建是用来解决一个问题： 构建数据实时更新的大型应用</p>
<h1 id="jie-shao-jsx"><a href="#介绍JSX" class="headerlink" title="介绍JSX"></a>介绍JSX<a href="jie-shao-jsx" class="header-anchor">"#"</a></h1><p>考虑一下下面的变量表达式：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, simmer!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div></pre></td></tr></table></figure></p>
<p>这个有趣的标签语法既不是字符串也不是HTML，实际上它叫做JSX，是一个JavaScript的语法扩展。看起来JSX是一个模版语言，但是它支持全面的JavaScript语法。</p>
<h3 id="jsx-zhong-de-qian-tao-biao-da-shi"><a href="#JSX中的嵌套表达式" class="headerlink" title="JSX中的嵌套表达式"></a>JSX中的嵌套表达式<a href="jsx-zhong-de-qian-tao-biao-da-shi" class="header-anchor">"#"</a></h3><p>你可以在JSX中通过大括号嵌套任何JavaScript语法。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatName</span>(<span class="params">user</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> user.firstName + <span class="string">' '</span> + user.lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> user = &#123;</div><div class="line">  firstName: <span class="string">'Harper'</span>,</div><div class="line">  lastName: <span class="string">'Perez'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> element = (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></div><div class="line">    Hello, &#123;formatName(user)&#125;!</div><div class="line">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">);</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  element,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>我们通过括号包裹JSX，并且为了可读性将它拆分成多行，这也有助于避免分号的自动插入。</p>
<h3 id="jsx-ye-shi-yi-ge-biao-da-shi"><a href="#JSX也是一个表达式" class="headerlink" title="JSX也是一个表达式"></a>JSX也是一个表达式<a href="jsx-ye-shi-yi-ge-biao-da-shi" class="header-anchor">"#"</a></h3><p>在编译以后，JSX表达式将会变成常规的JavaScript对象。</p>
<h3 id="zai-jsx-zhong-zhi-ding-shu-xing"><a href="#在JSX中指定属性" class="headerlink" title="在JSX中指定属性"></a>在JSX中指定属性<a href="zai-jsx-zhong-zhi-ding-shu-xing" class="header-anchor">"#"</a></h3><ul>
<li>可以通过引号来表达一个存文本的属性值</li>
<li>也可以使用大括号来嵌套JavaScript表达式作为属性值</li>
</ul>
<h3 id="zai-jsx-zhong-zhi-ding-zi-yuan-su"><a href="#在JSX中指定子元素" class="headerlink" title="在JSX中指定子元素"></a>在JSX中指定子元素<a href="zai-jsx-zhong-zhi-ding-zi-yuan-su" class="header-anchor">"#"</a></h3><ul>
<li>空标签可以使用<code>/&gt;</code>闭合标签</li>
<li>JSX标签也可以包含子元素</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = (</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Good to see you here.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">);</div></pre></td></tr></table></figure>
<blockquote>
<p>警告<br>由于JSX比HTML更接近JavaScript， React DOM 使用驼峰属性命名规则而不是HTML的属性名，例如 在JSX中<code>class</code>变成了<code>className</code>，<code>tabindex</code>变成了<code>tabIndex</code>.</p>
</blockquote>
<h3 id="jsx-fang-zhi-zhu-ru-gong-ji"><a href="#JSX-防止注入攻击" class="headerlink" title="JSX 防止注入攻击"></a>JSX 防止注入攻击<a href="jsx-fang-zhi-zhu-ru-gong-ji" class="header-anchor">"#"</a></h3><p>默认情况下，在渲染前React DOM会阻止在JSX中嵌入任何值。</p>
<h1 id="xuan-ran-yuan-su"><a href="#渲染元素" class="headerlink" title="渲染元素"></a>渲染元素<a href="xuan-ran-yuan-su" class="header-anchor">"#"</a></h1><p>元素是构建React应用的最小化模块。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">hello</span> , <span class="attr">simmer</span> /&gt;</span>;</span></div></pre></td></tr></table></figure></p>
<p>不同于浏览器的DOM元素，React元素是纯对象并且创建所花费的代价很小。 React DOM则更关心根据React元素来更新DOM。</p>
<blockquote>
<p>提示<br>一个可能会使得元素变得疑惑的点是被更加广泛熟知的‘组件’概念。我们将会在下一届介绍组件。组件是通过元素来构成的，并且我们鼓励你在跳到后面内容前先阅读本节内容。</p>
</blockquote>
<h3 id="xuan-ran-yi-ge-yuan-su-dao-dom-zhong"><a href="#渲染一个元素到DOM中" class="headerlink" title="渲染一个元素到DOM中"></a>渲染一个元素到DOM中<a href="xuan-ran-yi-ge-yuan-su-dao-dom-zhong" class="header-anchor">"#"</a></h3><p>为了渲染一个React元素到DOM根节点，将他们同时传入<code>ReactDOM.render()</code>中。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div><div class="line">ReactDOM.render(</div><div class="line">  element,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">);</div></pre></td></tr></table></figure>
<h3 id="geng-xin-xuan-ran-yuan-su"><a href="#更新渲染元素" class="headerlink" title="更新渲染元素"></a>更新渲染元素<a href="geng-xin-xuan-ran-yuan-su" class="header-anchor">"#"</a></h3><p>React元素是不可变的，一旦你创建了一个元素后就无法改变它的子元素或者属性。这就像是电影里的一帧，代表的是在某一时刻的UI。<br>目前我们熟知的更新UI的方法是创建一个新的元素并且把它传到<code>ReactDOM.render()</code>中。</p>
<h1 id="zu-jian-he-shu-xing"><a href="#组件和属性" class="headerlink" title="组件和属性"></a>组件和属性<a href="zu-jian-he-shu-xing" class="header-anchor">"#"</a></h1><p>组件让你将UI拆分为独立的，可复用的，可已独立思考的模块。<br>从概念上讲，组件就像是JavaScript函数。他们接受任意的输入（叫做’Props’）并且返回能描述当前UI表现的React元素。</p>
<h3 id="functional-and-class-components"><a href="#Functional-and-Class-Components" class="headerlink" title="Functional and Class Components"></a>Functional and Class Components<a href="functional-and-class-components" class="header-anchor">"#"</a></h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">	render() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="xuan-ran-yi-ge-zu-jian"><a href="#渲染一个组件" class="headerlink" title="渲染一个组件"></a>渲染一个组件<a href="xuan-ran-yi-ge-zu-jian" class="header-anchor">"#"</a></h4><p>在前面我们遇到的React元素仅仅代表DOM标签<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span>/&gt;</span></span><span class="string">''</span></div></pre></td></tr></table></figure></p>
<p>然而，元素也可以代表用户定义的组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sunny"</span> /&gt;</span>;</span></div></pre></td></tr></table></figure></p>
<p>当React发现某一个原属代表的是一个用户定义好的组件，并且将JSX的属性作为一个对象传递到组件中。我们叫这个对象为”props”。</p>
<p>下面是一个栗子，它渲染”Hello, Sunny”到页面中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sunny"</span> /&gt;</span>;</span></div><div class="line">ReactDOM.render(</div><div class="line">  element,</div><div class="line">  document.getElementById('root')</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>让我们来简要概括一下在这个栗子中发生了什么：</p>
<ul>
<li>我们调用<code>ReactDOM.render()</code>并且传递<code>&lt;Welcome name=&quot;Sunny&quot; /&gt;</code>这个元素到其中。</li>
<li>React 调用<code>Welcome</code>组件并且将<code>{name: &quot;Sunny&quot;}</code>作为<code>props</code>传递到组件中。</li>
<li>组件<code>Welcome</code>返回<code>&lt;h1&gt;hello, Sunny&lt;/h1&gt;</code>元素作为结果。</li>
<li>ReactDOM 有效率的更新DOM来匹配<code>&lt;h1&gt;hello, Sunny&lt;/h1&gt;</code>。</li>
</ul>
<h3 id="bian-xie-zu-jian-amp-amp-jie-gou-zu-jian"><a href="#编写组件-amp-amp-解构组件" class="headerlink" title="编写组件 &amp;&amp; 解构组件"></a>编写组件 &amp;&amp; 解构组件<a href="bian-xie-zu-jian-amp-amp-jie-gou-zu-jian" class="header-anchor">"#"</a></h3><ul>
<li>组件嵌套</li>
<li>将组件进行拆分，可以有效的复用组件<h3 id="props-shi-zhi-du-de"><a href="#Props是只读的" class="headerlink" title="Props是只读的"></a>Props是只读的<a href="props-shi-zhi-du-de" class="header-anchor">"#"</a></h3>看一个简单的函数：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">functon addResult(a. b) &#123;</div><div class="line">	<span class="keyword">return</span> a +b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的函数被叫做是纯函数因为他们不会试图去改变输入，并且同样的输入总会有同样的输出。</p>
<blockquote>
<p>为了反映他们的props，所有的React组件必须按表现的像一个纯函数一样。</p>
</blockquote>
<h1 id="zhuang-tai-he-sheng-ming-zhou-qi"><a href="#状态和生命周期" class="headerlink" title="状态和生命周期"></a>状态和生命周期<a href="zhuang-tai-he-sheng-ming-zhou-qi" class="header-anchor">"#"</a></h1><p>略<br>tips: 如果你没有在<code>render</code>方法中没有使用一些数据，那么它们就不该出现在<code>state</code>中</p>
<h2 id="zheng-que-de-shi-yong-state"><a href="#正确的使用State" class="headerlink" title="正确的使用State"></a>正确的使用State<a href="zheng-que-de-shi-yong-state" class="header-anchor">"#"</a></h2><h3 id="bu-yao-zhi-jie-xiu-gai-state"><a href="#不要直接修改State" class="headerlink" title="不要直接修改State"></a>不要直接修改State<a href="bu-yao-zhi-jie-xiu-gai-state" class="header-anchor">"#"</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.state.comment = <span class="string">"hello"</span>; <span class="comment">// wrong</span></div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line">上面的方法将不会触发React的重新渲染，所以应该使用以下方法：</div><div class="line">`<span class="string">``</span>js</div><div class="line"><span class="comment">// Correct</span></div><div class="line"><span class="keyword">this</span>.setState(&#123;comment: <span class="string">"hello"</span>&#125;);</div></pre></td></tr></table></figure>
<h3 id="zhuang-tai-de-geng-xin-ke-neng-shi-yi-bu-de"><a href="#状态的更新可能是异步的" class="headerlink" title="状态的更新可能是异步的"></a>状态的更新可能是异步的<a href="zhuang-tai-de-geng-xin-ke-neng-shi-yi-bu-de" class="header-anchor">"#"</a></h3><p>为了性能方面的考虑，React可能会将批量的<code>setState()</code>方法合并为一次简单的更新。<br>也正是由于<code>this.props</code>和<code>this.state</code>可能是异步更新的，你不能根据它们的值来计算下一次的状态。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Wrong</span></div><div class="line"><span class="keyword">this</span>.setState(&#123;</div><div class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>为了修复这个问题，我们可以用第二种方法来调用<code>setState()</code>,那就是传递一个函数而不是一个对象进去。这个函数将会接受前一时刻的state最为第一个参数，更新被应用时的props作为第二个参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.setState((prevState, props) =&gt; (&#123;</div><div class="line">	counter: prevState.counter + props.increment    <span class="comment">// Correct</span></div><div class="line">&#125;))</div></pre></td></tr></table></figure></p>
<h3 id="state-de-geng-xin-shi-yi-ci-he-bing"><a href="#State的更新是一次合并" class="headerlink" title="State的更新是一次合并"></a>State的更新是一次合并<a href="state-de-geng-xin-shi-yi-ci-he-bing" class="header-anchor">"#"</a></h3><p>当你调用<code>setState()</code>方法的时候，React将会合并你提供的对象到当前的state中。<br>注意： state的合并是浅合并。</p>
<h1 id="chu-li-shi-jian"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件<a href="chu-li-shi-jian" class="header-anchor">"#"</a></h1><p>首先注意在JSX中的事件和处理DOM的事件有些不同。</p>
<ul>
<li>React事件的取名是驼峰式的，不是小写方式的。</li>
<li>在JSX中传递一个函数作为事件处理函数，而不是字符串。</li>
<li>在React中不能通过返回false来阻止浏览器的默认行为，而是需要使用<code>preventDetault</code></li>
</ul>
<p>使用ES2015 class语法定义组件，一般的建议是在constructor中绑定好事件处理的handler/或者使用箭头函数</p>
<h3 id="you-tiao-jian-de-xuan-ran"><a href="#有条件的渲染" class="headerlink" title="有条件的渲染"></a>有条件的渲染<a href="you-tiao-jian-de-xuan-ran" class="header-anchor">"#"</a></h3><p>略</p>
<h3 id="lie-biao-he-key"><a href="#列表和key" class="headerlink" title="列表和key"></a>列表和key<a href="lie-biao-he-key" class="header-anchor">"#"</a></h3><p>略</p>
<h3 id="biao-dan"><a href="#表单" class="headerlink" title="表单"></a>表单<a href="biao-dan" class="header-anchor">"#"</a></h3><p>区分受控表单和非受控表单的区别</p>
<h1 id="ti-qu-gong-gong-zhuang-tai"><a href="#提取公共状态" class="headerlink" title="提取公共状态"></a>提取公共状态<a href="ti-qu-gong-gong-zhuang-tai" class="header-anchor">"#"</a></h1><p>通常，如果组件需要重新渲染，我们首先会想到添加一个state到组件中。接着，当其他的组件也需要这个状态的时候，最好的做法是将状态提升到它们（组件）最近的共同祖先，而不是是这在不同的组件之间尝试同步状态，换句话说，你需要依靠这种自上而下的数据流。</p>
<h1 id="zu-cheng-vs-ji-cheng"><a href="#组成-Vs-继承" class="headerlink" title="组成 Vs 继承"></a>组成 Vs 继承<a href="zu-cheng-vs-ji-cheng" class="header-anchor">"#"</a></h1><p>未完待续</p>
</div></article></div><div class="paginator clearfix"><a href="/2016/12/29/other/summary-about-2016/" class="prev">上一篇</a><a href="/2016/05/03/backend/nodejs-server/" class="next">下一篇</a></div></section><section class="footer"><div>Host By Github Pages | Thans For Coming | Hexo Theme <a href="https://github.com/Simmer-Jun/hexo-theme-grace">Grace</a></div><div class="copyright">© 2017 <a href="/about/index.html">Simmer</a>. All rights reserved.</div><div id="go-pg-top" style="display: none; opacity: 0.6;" title="返回顶部">TOP</div></section></div></div><script src="/js/jquery-1.11.1.js"></script><script src="/js/common.js"></script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1257488449' class='cnzz'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1257488449%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></body></html>