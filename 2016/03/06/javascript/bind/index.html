<!DOCTYPE html><html class="no-js"><head><meta charset="utf-8"><title>司马-Simmer-浅谈 javascript 中的bind</title><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.icon"><link rel="stylesheet" href="/css/style.css"><!-- detech broser's env --><script src="/js/modernizr.js" type="text/javascript"></script><meta name="description" content="A Blog Powered By Hexo"></head><body><div class="nav clearfix nav-show"><div title="隐藏导航" id="nav-btn" class="nav-guide"><i class="icon nav-icon">&#xe603;</i></div><div class="nav-inner  clearfix"><a href="/" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe606;</div><span>Home</span></div></a><a href="/archives" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe602;</div><span>Archives</span></div></a><a href="/photography" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe604;</div><span>摄影</span></div></a><a href="/tags" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe601;</div><span>Tags</span></div></a><a href="/about" class="nav-item"><div class="nav-item-inner"><div class="icon">&#xe605;</div><span>About</span></div></a></div></div><div class="wraper"><div class="main"><section class="content"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2016/03/06/javascript/bind/" class="post-title-link">浅谈 javascript 中的bind</a></h2><div class="post-subtitle clearfix"><span class="post-date">2016年3月6日</span><div class="post-tag"><a href="/2016/03/06/javascript/bind/"><sapn>JavaScript</sapn><i class="icon">&#xe600;</i></a></div></div><div class="post-content"><p>关于JavaScript的<code>bind</code>相信作为一名FEer都不会感到陌生，由于<code>JavaScript</code>中有着一个特殊的值–<code>this</code>的存在，一个函数可以在不同的上下文中被调用，所以关于<code>this</code>我们要学会去分辨不同的场景，这样才能更好的去运用JavaScript这门灵活的语言</p>
<a id="more"></a>
<h2 id="call-amp-amp-apply-amp-amp-bind"><a href="#call-amp-amp-apply-amp-amp-bind" class="headerlink" title="call &amp;&amp; apply &amp;&amp; bind"></a>call &amp;&amp; apply &amp;&amp; bind<a href="call-amp-amp-apply-amp-amp-bind" class="header-anchor">"#"</a></h2><p>在真正的开始之前我们先来复习一些基本知识.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.call(thisToBind[,arg1, arg2, ...]);</div><div class="line"><span class="built_in">Function</span>.prototype.apply(thisToBind[,rest <span class="built_in">arguments</span>]);</div><div class="line"><span class="built_in">Function</span>.prototype.bind(thisToBind[,arg1,arg2,...]);</div></pre></td></tr></table></figure></p>
<h4 id="gong-tong-dian"><a href="#共同点" class="headerlink" title="共同点:"></a>共同点:<a href="gong-tong-dian" class="header-anchor">"#"</a></h4><p>传入的第一个参数都能作为该函数运行时候的<code>this</code>值。(都能显示的改变某个函数运行时候的<code>this</code>)</p>
<h4 id="bu-tong-dian"><a href="#不同点" class="headerlink" title="不同点:"></a>不同点:<a href="bu-tong-dian" class="header-anchor">"#"</a></h4><p><code>call</code> 返回一个函数的运行结果，接受改函数的参数以明确的个数传入。<br><code>apply</code>返回一个函数的运行结果，接受的参数可以是数组或者是类数组对象。(什么是类数组对象？可以通过obj[0]这样数字属性访问，但是没有数组的方法(就是不能使用类似<code>obj.push()</code>)<br><code>bind</code> 返回一个函数，该函数运行时内部的<code>this</code>值将会指向<code>bind</code>方法调用时候传入的第一个值，并且同一个函数不能同时<code>bind</code>2次或更多，这点等下我会和大家说到。</p>
<h3 id="han-shu-ke-li-hua"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化<a href="han-shu-ke-li-hua" class="header-anchor">"#"</a></h3><p>什么是函数柯里化？这里引用<a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="external">wikipedia</a>上的定义:</p>
<blockquote>
<p>柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
</blockquote>
<p>这里说的很清楚了，函数柯里化其实就是将函数一次性接受所有参数进行调用的方式改变了一下而已，它可能是这个样子的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">methodA(a, b, c) === methodACurrying(a)(b, c);</div></pre></td></tr></table></figure>
<p>就是一个函数珂里化之后返回一个新的函数，这个函数保存着之前首次调用传入的参数<code>a</code>，并且在该函数执行的时候将之前的参数<code>a</code>加上<code>b,c</code>作为参数一起调用，也就相当于以<code>methodA(a, b, c)</code>的调用形式<br>有点不懂？没关系，我们来看下面一个简单的函数柯里化(currying)的栗子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"> </span>) </span>&#123;  <span class="comment">// 定义一个简单的加函数</span></div><div class="line">  <span class="keyword">var</span> result = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++) &#123;</div><div class="line">    result += <span class="built_in">arguments</span>[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123; <span class="comment">// count函数实现add函数的柯里化 既count(a)(b ,c) &lt;==&gt; add(a, b, c)</span></div><div class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> add.apply(<span class="built_in">window</span>, args.concat(<span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>)));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">log(add.bind(<span class="built_in">window</span>,<span class="number">1</span>)(<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">// 6</span></div><div class="line">log(count(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></div><div class="line">log(count(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 6</span></div><div class="line">log(count(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)()); <span class="comment">// 6</span></div></pre></td></tr></table></figure></p>
<p>可以看到，通过使用强大的闭包我们实现了函数柯里化。</p>
<ul>
<li>我们定义了一个<code>count</code>函数，在这个函数内部我们县通过<code>call</code>将<code>count</code>函数传入的参数进行了数组化(保存在变量<code>args</code>中)，并且最后它返回的是一个函数，这个函数包含着对<code>args</code>变量的引用，所以能够保证在<code>count</code>函数运行返回的匿名函数中依旧能够访问到<code>args</code></li>
<li>这个变量，这个知识属于JavaScirpt中的闭包知识，详情可以查看<a href="">这里</a>。</li>
<li>现在我们在返回的匿名函数内部对<code>add</code>函数使用<code>apply</code>方法 add函数如何能调用apply？因为add是Function类的一个实例所以能够访问到<code>Function.prototype.apply</code>实例公共方法，巧妙的通过<code>args</code>变量(在count函数中已经被转化为数组了)的concat方法将后面传入的参数先数组化然后再进行合并。</li>
</ul>
<p>简直就是一气呵成的啊^-^ my god !!!<br>别急!!! 但是这个和bind有关系么???当然有啦，我们可以看到在log第一行我们是使用了<code>add.bind(window, 1)(2, 3)</code>的形式来调用的，它比我们上面的<code>count</code>函数多了一个优点，那就是<code>this</code>值的绑定，使用<code>bind</code>传入的第一个参数会成为后面新函数运行的<code>this</code>值就是函数运行的上下文，而我上面定义的count方法是没有绑定<code>this</code>值的功能的.<br>现在我们可以看看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">MDN</a>上面关于bind的解释: </p>
<blockquote>
<p> bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
</blockquote>
<p>这个定义是不是很熟悉？答案是是的，它和我们上面提到的函数柯里化定义几乎一样，除了一个地方，那就是<em><code>bind</code>有绑定<code>this</code>的功能</em>而我们上面提到的柯里化是没有包含绑定<code>this</code>这一项的</p>
<h3 id="you-hua"><a href="#优化" class="headerlink" title="优化"></a>优化<a href="you-hua" class="header-anchor">"#"</a></h3><p>上面我们简单实现的<code>count</code>函数其实离<code>bind</code>还有一些距离，比如：</p>
<ul>
<li>返回的函数没有绑定<code>this</code></li>
<li>只能通过<code>count()</code>对它进行调用</li>
</ul>
<p>那么如何让所有的function类都能使用count方法呢？我们来改装一下count函数，并把它挂载在<code>Funcition.prototype</code>Funcition这个原型对象上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// save this</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> add.apply(self, args.concat(<span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>)));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(!<span class="built_in">Function</span>.prototype.count) &#123;</div><div class="line">  <span class="built_in">Function</span>.prototype.count = count;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>好了现在看起来好像是添加了绑定<code>this</code>功能并且每个funcition类都能访问了。但是有一天我们发现这样还是太麻烦了，设想一下，我们这里只是让每个函数绑定count方法，那么如果还有减法运算和乘法运算呢？我们难道一个个的去添加到Function的原型上？(这里举例的加减乘法只是例子，实际的项目需求当然会有很多不同功能的函数)，伟大的开发者也想到了，这个根本不是办法啊？于是乎，bind方法就这样出现了。</p>
<h3 id="bind-zhi-duo-shao"><a href="#bind-知多少" class="headerlink" title="bind 知多少"></a>bind 知多少<a href="bind-zhi-duo-shao" class="header-anchor">"#"</a></h3><p>分分钟实现一个bind方法啊有木有~<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">ObjToBind</span>) </span>&#123; <span class="comment">// ObjToBind =&gt; 在self调用的时候函数内部this的指向</span></div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// save this</span></div><div class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>); <span class="comment">// 数组化 去掉传入的第一个参数</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 返回匿名函数(闭包)</span></div><div class="line">      self.apply(ObjToBind, args.concat([].slice.call(<span class="built_in">arguments</span>))); <span class="comment">// 合并参数执行函数</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>由于<code>Function.prototype.bind</code>方法是在ECMAScript5中才被添加进去的，对于IE8下这种远古浏览器来说是无法理解的，但是可能我们实际的项目中用到了bind方法同时我们也需要去兼容IE8，这个时候就要人为手动的去扩展<code>Function.prototype</code>对象上的方法了，我们来优化一下上面的bind方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="built_in">Function</span>.prototype.bind || <span class="function"><span class="keyword">function</span> (<span class="params">ObjToBind </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// save this</span></div><div class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>); <span class="comment">// 数组化 </span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      self.apply(ObjFnToBind, args.concat([].slice.call(<span class="built_in">arguments</span>)));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>上面的代码做了几件事情:</p>
<ul>
<li>使用立即执行匿名表达式(IIFE) －－－ Immediately-Invoked Function Expression 避免全局污染</li>
<li>只需要运行一次匿名函数即可解决<code>bind</code>问题 无需每次调用<code>bind</code>检查是否存在<code>Function.prototype</code>上面</li>
<li>返回的函数可以接受任意个数的参数来进行调用，这得益于<code>apply</code>的使用</li>
</ul>
<p>这就是bind的好处，能够绑定函数运行的上下文。试想一下，一些事件处理程序里面，我们往往要注意<code>this</code>的取值，因为在这些事件处理程序里面的<code>this</code>值会有所不同，这个时候如果我们能对这些事件处理函数来进行<code>bind</code>的话，那就可以放心的在事件handle里面使用<code>this</code>啦～～～～但是我们上面只是简单的实现了<code>bind</code>，在想一下我们通过执行<code>bind</code>方法返回的匿名函数还是有缺陷的</p>
<ul>
<li>比如说如果我们绑定的函数原型上有许多我们定义好的方法，但是这个返回的匿名函数只是简单的包裹了一下，在这个匿名函数下调用在前面被绑定函数对象原型上面定义的方法属性并不能够被访问。</li>
</ul>
<p>啥？没听懂？抱歉我语言表达能力还是有待加强，那我们还是来上代码吧～小儿，给我来一壶上好的代码~~</p>
<h2 id="mdn-bind-polyfill"><a href="#MDN-Bind-polyfill" class="headerlink" title="MDN Bind polyfill"></a>MDN Bind polyfill<a href="mdn-bind-polyfill" class="header-anchor">"#"</a></h2><p>那么如何更加优雅的实现原生的<code>bind</code>函数呢？ 让我们一起来看看MDN上的关于bind方法的Polifill吧<br>具体的例子可以看下面这段代码，摘抄自<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">MDN Bind</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</div><div class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">oThis</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</div><div class="line">      <span class="comment">// closest thing possible to the ECMAScript 5</span></div><div class="line">      <span class="comment">// internal IsCallable function</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>), </div><div class="line">        fToBind = <span class="keyword">this</span>, </div><div class="line">        fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> fToBind.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP</div><div class="line">                                 ? <span class="keyword">this</span></div><div class="line">                                 : oThis || <span class="keyword">this</span>,</div><div class="line">                               aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</div><div class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fBound;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="fen-xi-bind-de-shi-xian"><a href="#分析Bind的实现" class="headerlink" title="分析Bind的实现"></a>分析Bind的实现<a href="fen-xi-bind-de-shi-xian" class="header-anchor">"#"</a></h3><p>可能大家对于上面的代码会有一些疑惑，我当时是看了好好多遍，自己想了好几次才全部明白这其中的原理，真的不得不佩服前辈们的思维深度和思维广度，把一切问题都想到了！我们来一步步分析吧</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</div><div class="line">    <span class="comment">// closest thing possible to the ECMAScript 5</span></div><div class="line">    <span class="comment">// internal IsCallable function</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>检测调用<code>bind</code>方法的 是不是函数，如果不是函数的话那还玩个球啊。直接抛出错误并返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>), <span class="comment">// 参数数组化 make to array</span></div><div class="line">   fToBind = <span class="keyword">this</span>, <span class="comment">// save this 保存调用bind的函数对象</span></div><div class="line">   fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="comment">// 定义一个空函数 后面会讲到他的意义 这里就知道有这么一个空的函数就好了。</span></div><div class="line">   fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; ... <span class="comment">// bind运行返回的函数</span></div></pre></td></tr></table></figure>
<p>这一步定义了一些变量，包括保存调用的数组<code>aArgs</code>，调用<code>bind</code>的函数<code>fToBind</code>，返回的函数<code>fBound</code>，还有一个神秘的空函数<code>fNOP</code>，对于<code>fNOP</code>我们打个问号一？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> fToBind.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP</div><div class="line">                      ? <span class="keyword">this</span></div><div class="line">                      : oThis || <span class="keyword">this</span>,</div><div class="line">                      aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里就是定义返回函数内部的逻辑了，我和我们上面自己实现的简单<code>bind</code>函数返回的匿名函数还是有些区别的,比如说第一个参数这里是用了条件运算符<code>this instanceof fNOP ? this : oThis || this</code> 这里打个问号二？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fNOP.prototype = <span class="keyword">this</span>.prototype; <span class="comment">// 让空函数的原型执行this原型</span></div><div class="line">fBound.prototype = <span class="keyword">new</span> fNOP(); <span class="comment">// 返回的函数原型为空函数的实例 保存着指向fNOP的原型的指针 </span></div><div class="line"><span class="keyword">return</span> fBound;</div></pre></td></tr></table></figure></p>
<p>看到这里终于恍然大悟了，这个不是继承么，通过一个空函数作为中介，让返回的<code>fBound</code>函数的原型链上包含<code>this</code>也就是调用<code>bind</code>的函数。这个也就解决了我们上面所说的<code>bind</code>后的函数原型链的中断的情况。问号一解决!!!</p>
<p>谢谢大家阅读，再见~<br>哎，等等，卧槽，还有问题二呢!!!! 泥TM是在逗我啊，挖坑不填充，菊花万人捅org<br>回归原意，<code>this instanceof fNOP ? this : oThis || this</code> 判断<code>this</code>的原型链上有<code>fNOP</code>么，如果包含就说明了<code>fNOP</code>函数是被作为函数构造器调用的，所以这里的<code>this</code>就不能够是<code>oThis</code>啦，而应该正确的指向实例化的新的对象。如果函数不是作为函数构造器调用，正确的传入<code>oThis</code>就好了。还有一点必须要提醒大家的就是，一个函数只能被<em><code>bind</code>一次，一次，一次</em> 因为调用<code>bind</code>函数返回的函数里面已经指定死了<code>this</code>的值了，我们无法再去改变<code>fToBind.apply(oThis)</code>中的<code>oThis</code>，因为他访问的是外层闭包的取值。</p>
<p>现在再去回过头细细品味上面的bind polyfill 你应该会有不一样的收获吧？ Enjoy it!</p>
<p>(完)</p>
</div></article></div><div class="paginator clearfix"><a href="/2016/03/14/javascript/printStar/" class="prev">上一篇</a><a href="/2016/02/15/javascript/js-this/" class="next">下一篇</a></div></section><section class="footer"><div>Host By Github Pages | Thans For Coming | Hexo Theme <a href="https://github.com/Simmer-Jun/hexo-theme-grace">Grace</a></div><div class="copyright">© 2017 <a href="/about/index.html">Simmer</a>. All rights reserved.</div><div id="go-pg-top" style="display: none; opacity: 0.6;" title="返回顶部">TOP</div></section></div></div><script src="/js/jquery-1.11.1.js"></script><script src="/js/common.js"></script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1257488449' class='cnzz'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1257488449%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></body></html>